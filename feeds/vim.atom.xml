<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Blank File</title><link href="https://miyakogi.github.io/blog/" rel="alternate"></link><link href="https://miyakogi.github.io/blog/feeds/vim.atom.xml" rel="self"></link><id>https://miyakogi.github.io/blog/</id><updated>2016-03-08T23:20:00+09:00</updated><entry><title>Vimのパッケージをインストール・アップデートしてヘルプ作るスクリプトを書きました</title><link href="https://miyakogi.github.io/blog/20160308/vimpack_py.html" rel="alternate"></link><updated>2016-03-08T23:20:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-03-08:blog/20160308/vimpack_py.html</id><summary type="html">&lt;p&gt;先日からVim本体のパッケージ機能を使い、プラグインマネージャは使わない生活をしています。
とはいえプラグインのアップデートやヘルプの生成は手作業では面倒なので、そのあたりを処理してくれるPythonのスクリプトを書きました。&lt;/p&gt;
&lt;p&gt;始めは&lt;a href="https://github.com/miyakogi/dotfiles"&gt;dotfileをgit管理&lt;/a&gt;（今まではhgで管理してbitbucketに置いてました）にしてプラグインをsubmoduleにすれば十分かと思ったのですが、やってみたら意外と面倒でした。
Pythonで書いたのは、自分の場合VimがあるところならまずPythonもあるというのと、3.4で入った&lt;a href="http://docs.python.jp/3/library/pathlib.html"&gt;pathlib&lt;/a&gt;というパスをいい感じに扱えるライブラリを使ってみたかったからです。&lt;/p&gt;
&lt;p&gt;この記事を書きながらログ周りやオプションを整備してリファクタリングもしましたが、あくまで自分用に書いたスクリプトなので機能は最低限です。
gitにしか対応していませんが、パッケージ機能を試したい方はもし良ければお使いください。
なお、Vimのパッケージ機能についてはヘルプや&lt;a href="http://h-miyako.hatenablog.com/entry/2016/02/29/211534"&gt;先日の記事&lt;/a&gt;をご参照ください。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h4&gt;修正&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトで読み込むパスが&lt;code&gt;ever&lt;/code&gt;から&lt;code&gt;start&lt;/code&gt;に変更されたので修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;機能&lt;/h2&gt;
&lt;p&gt;インストール、アップデート、チェックの3つの機能があります。
インストールするプラグインをJSON形式で記述して &lt;code&gt;~/.vim/pack/{好きな名前}/pack.json&lt;/code&gt; に置いておくと勝手に読み込みます。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;インストールは不要です。
標準ライブラリ以外の依存もありません。
ファイル（&lt;a href="https://github.com/miyakogi/dotfiles/blob/master/vimpack.py"&gt;最新版&lt;/a&gt;または&lt;a href="https://github.com/miyakogi/dotfiles/blob/36fc432b5bee58b40f871ceb19c7e903fa483cd8/vimpack.py"&gt;今日のバージョン&lt;/a&gt;）を適当なところに保存して実行するだけです。
実行権限をつけてパスの通った所に置いておけば手軽に実行できます。&lt;/p&gt;
&lt;p&gt;実行にはPython3.5以上が必要です。
もしかしたら3.4でも動くかもしれませんが未確認です。&lt;/p&gt;
&lt;p&gt;なお、この記事の内容は今日のバージョンベースです。
Vimの仕様変更や私の気分次第で最新版は記事の内容と異なる場合がありますのでご注意下さい。&lt;/p&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;実行は &lt;code&gt;python3 vimpack.py {コマンド} [設定ファイル名（デフォルトpack.json）]&lt;/code&gt; です。
コマンドは必須で、設定ファイルの名前はオプションです。&lt;/p&gt;
&lt;p&gt;インストールしたいリポジトリの情報を記入した &lt;code&gt;pack.json&lt;/code&gt; というファイルを &lt;code&gt;~/.vim/pack/{好きな名前}&lt;/code&gt; のディレクトリに置いておきます。
この設定ファイルに書かれたリポジトリがそのディレクトリの下の&lt;code&gt;start&lt;/code&gt;または&lt;code&gt;opt&lt;/code&gt;ディレクトリにcloneされます。
以下のように複数のディレクトリに設定ファイルを置くこともできます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/.vim/pack
├── 好きな名前1
│   ├── pack.json
│   ├── opt
│   └── start
├── 好きな名前2
│   ├── pack.json
│   ├── opt
│   └── start
└── 好きな名前3
    ├── pack.json
    ├── opt
    └── start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;※注: Vim 7.4.1527以前のバージョンでは&lt;code&gt;start&lt;/code&gt;ではなく&lt;code&gt;ever&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;設定ファイルのフォーマット&lt;/h3&gt;
&lt;p&gt;現時点では次のようなフォーマットにしています。
Vimの仕様変更や私の気分次第で変わるかもしれません。
もし動かなかったら&lt;a href="https://github.com/miyakogi/dotfiles/blob/master/pack.json"&gt;私の設定ファイル&lt;/a&gt;を確認してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;&amp;#39;start&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;&amp;#39;github.com&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;username1/plugin_repo&amp;#39;,&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;other_user/plugin_repo2&amp;#39;&lt;/span&gt;
        &lt;span class="err"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;
    &lt;span class="err"&gt;&amp;#39;opt&amp;#39;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;&amp;#39;github.com&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;another_user/plugin&amp;#39;,&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;another_user/somplugin&amp;#39;&lt;/span&gt;
        &lt;span class="err"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JSONなので末尾コンマ禁止です。エラーになります。
苦情はPython標準ライブラリの&lt;a href="http://docs.python.jp/3/library/json.html"&gt;json&lt;/a&gt;モジュールにお願いします。&lt;/p&gt;
&lt;p&gt;必ず読み込むプラグインは&lt;code&gt;start&lt;/code&gt;以下に、遅延読み込みしたいものは&lt;code&gt;opt&lt;/code&gt;以下に記述します。
それぞれのディレクトリに配下のリポジトリがクローンされます。
リポジトリの指定は&lt;code&gt;{ホスト名: [リポジトリ1, リポジトリ2, ...]}&lt;/code&gt;という形のホスト名をキーとしたリストになります。&lt;/p&gt;
&lt;p&gt;github以外からインストールする時はホスト名を追加して別に配列を持たせてください。
名前の衝突は一切考慮していないので、万一衝突した場合は先にcloneされたほうが勝ちます。
なお、一度Pythonの辞書オブジェクトに変換される都合上順番はランダムになります。&lt;/p&gt;
&lt;h3&gt;インストール&lt;/h3&gt;
&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;勝手に設定ファイルを探してきて、丁寧に一つずつcloneします。
すでにディレクトリがある場合はcloneせずにスキップします。
並列実行をしないのは面倒そうだった（特にログ出力）からです。
全部まとめてインストールとかそう何度もしないと思うので、のんびりコーヒーでも飲みながら眺めていてください。&lt;/p&gt;
&lt;p&gt;ちなみに、ログはカラー対応のターミナルだと色がつきます。
ここはがんばりました。
対応していない端末だと色がつかないだけでなく制御文字がそのまま表示されて残念な感じになります。
これを機に色の出る端末に乗り換えましょう。&lt;/p&gt;
&lt;p&gt;インストールされたプラグインに&lt;code&gt;plugin&lt;/code&gt;ディレクトリがなかった場合は作って&lt;code&gt;_.vim&lt;/code&gt;というダミーのファイルを作成します。
気になる方はグローバルな&lt;code&gt;.gitignore&lt;/code&gt;に追加しておいてください。
ついでに&lt;code&gt;doc&lt;/code&gt;ディレクトリの中身を&lt;code&gt;~/.vim/doc&lt;/code&gt;以下にリンクし、ヘルプ用のタグファイルを作成します。
これらの処理は&lt;code&gt;--no-dummy&lt;/code&gt;や&lt;code&gt;--no-doc&lt;/code&gt;オプションをつけることでスキップできます。&lt;/p&gt;
&lt;h3&gt;アップデート&lt;/h3&gt;
&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py update
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これを実行すると、&lt;code&gt;pack.json&lt;/code&gt;に記述されたリポジトリだけでなく、JSONのキーとして存在しているディレクトリ（&lt;code&gt;start&lt;/code&gt;と&lt;code&gt;opt&lt;/code&gt;）のgitリポジトリを全てアップデート（&lt;code&gt;git pull&lt;/code&gt;）します。
&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;も実行しているので多分submoduleも更新できると思います。
なお、設定ファイルに書かれていてもインストールされていないリポジトリは無視します。&lt;/p&gt;
&lt;p&gt;インストールの場合と同様、ダミーファイルの作成とヘルプの更新も行います。
同じくオプションでスキップ可能です。&lt;/p&gt;
&lt;h3&gt;チェック&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py check
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;設定ファイルにないリポジトリや未インストールのリポジトリを確認して、もしあれば警告を出します。
ついでにダミーファイルの作成とヘルプの更新を行います。
git以外でプラグインを追加した時に便利かな、と思ってつくってみました。&lt;/p&gt;
&lt;h3&gt;オプション&lt;/h3&gt;
&lt;h4&gt;--help&lt;/h4&gt;
&lt;p&gt;ヘルプを表示します。
Pythonの&lt;a href="http://docs.python.jp/3/library/argparse.html"&gt;argparse&lt;/a&gt;が作ってくれるやつです。
オプションの確認ができます。&lt;/p&gt;
&lt;h4&gt;設定ファイル名&lt;/h4&gt;
&lt;p&gt;デフォルトは&lt;code&gt;pack.json&lt;/code&gt;です。
他の名前にしたい場合は &lt;code&gt;python vimpack.py check config.json&lt;/code&gt; などのように他のオプションの前に指定してください。
フルパスを指定するとそのファイルだけを読み込みます。&lt;/p&gt;
&lt;h4&gt;--no-dummy&lt;/h4&gt;
&lt;p&gt;ダミーファイルの作成をスキップします。&lt;/p&gt;
&lt;h4&gt;--no-doc&lt;/h4&gt;
&lt;p&gt;ヘルプファイルへのシンボリックリンク作成をスキップします。&lt;/p&gt;
&lt;h4&gt;--loglevel&lt;/h4&gt;
&lt;p&gt;出力するログのレベルを設定できます。
レベルは &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; などがあります。
大文字小文字は関係ありません。&lt;/p&gt;
&lt;p&gt;デフォルトは &lt;code&gt;info&lt;/code&gt; です。
&lt;code&gt;debug&lt;/code&gt;が最も詳細（たくさん）なログを表示します。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;初めてpathlibをガッツリ使ってみました。
少しクセがありますが、基本的に便利でいい感じでした。&lt;/p&gt;
&lt;p&gt;もしvimpack.pyのバグに気づいたら、コメントでもリポジトリのissueでもいいので教えていただけるとすごく嬉しいです。
機能追加は・・・しないと思いますので適当にいじってください。&lt;/p&gt;</summary><category term="vim"></category><category term="python"></category></entry><entry><title>Vimのパッケージ機能を試してみました</title><link href="https://miyakogi.github.io/blog/20160229/vim_pack.html" rel="alternate"></link><updated>2016-02-29T17:52:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-29:blog/20160229/vim_pack.html</id><summary type="html">&lt;p&gt;最近&lt;a href="https://github.com/Shougo/dein.vim"&gt;dein.vim&lt;/a&gt;がバズったりVim本体にパッケージ機能が追加されたり、Vim界隈は第二次プラグインマネージャ戦争の気配に包まれています &lt;em&gt;[要出典]&lt;/em&gt;。
dein.vimはすでにいくつか紹介記事がありますが、本体の方はあまり情報を見かけかなかったので先日試した結果を含めて紹介します。&lt;/p&gt;
&lt;p&gt;この機能は入ったばかりなので、今後仕様の変更があるかもしれませんし、バグもあるかもしれませんし、（たぶん）機能追加もあると思います。
記事の内容が古くなっているかもしれないので、日付とVimのバージョンをよく確認してください。&lt;/p&gt;
&lt;p&gt;試す人は本体のデバッグに自分のVimを捧げる気持ちでいきましょう。
バックアップ重要です。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;[2016/03/07: &lt;code&gt;:loadplugin&lt;/code&gt;が削除され&lt;code&gt;:packadd&lt;/code&gt;が追加されたので修正]&lt;/p&gt;
&lt;h2&gt;メリット&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;プラグインマネージャが裏で色々頑張ってくれていることが理解できる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;必要なもの&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最新のVim&lt;/li&gt;
&lt;li&gt;インストールするプラグイン&lt;/li&gt;
&lt;li&gt;たくさんエラーが出てもいいVim環境&lt;/li&gt;
&lt;li&gt;エラーやバグに負けない強い心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は Kubuntu 15.10 で試しました。
Vimのバージョンは7.4.1225くらいでした。&lt;/p&gt;
&lt;h3&gt;情報源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help packages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help :packadd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help 'packpath'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困ったら&lt;a href="https://github.com/vim/vim"&gt;ソースコード&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;とりあえずプラグインを入れてみる&lt;/h2&gt;
&lt;p&gt;プラグインを入れるディレクトリは大別して二種類です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/ever&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/opt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的には&lt;code&gt;ever&lt;/code&gt;以下に自動的に読み込んでほしいプラグインを置いて、&lt;code&gt;opt&lt;/code&gt;以下に必要な時に読み込む（遅延読込する）プラグインを置く形です。
すでにNeoBundleなどのプラグインマネージャを使っている場合はプラグインが一つのディレクトリにまとまっていると思いますので、その中身をまるっと&lt;code&gt;ever&lt;/code&gt;以下にコピーして&lt;code&gt;neobundle#begin()&lt;/code&gt;〜&lt;code&gt;neobundle#end()&lt;/code&gt;あたりを&lt;code&gt;if 0&lt;/code&gt;と&lt;code&gt;endif&lt;/code&gt;で囲めばすぐ試せます（微妙な仕様の違いがあるので、そのままだと大量のエラーを経験することになりますが）。&lt;/p&gt;
&lt;p&gt;例えばplugin1とplugin2を&lt;code&gt;ever&lt;/code&gt;以下に置く場合は次のようなディレクトリ構成になります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/.vim
├── pack
│   ├── mypack
│   │   ├── ever
│   │   │   ├── plugin1
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── README.md
│   │   │   ├── plugin2
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── readme.md
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;この状態でVimを起動すると、&lt;strong&gt;.vimrcなどを読み込んだ後に&lt;/strong&gt;自動的にplugin1とplugin2がruntimepathに追加されます。&lt;/p&gt;
&lt;p&gt;太字部分重要です。
つまりvimrcの中ではプラグインが定義するコマンドや関数は使えません。
例えば&lt;code&gt;NoeBundle ~&lt;/code&gt;とかやっていた部分は全滅します。
autoload関数も使えないので、設定で&lt;code&gt;call plugin#setup(...)&lt;/code&gt;などとしている部分も全滅です。
また、プラグインもロードされていないので、例えば&lt;code&gt;if neobundle#is_installed('プラグイン名')&lt;/code&gt;などのかわりに単純に&lt;code&gt;if get(g:, 'loaded_プラグイン名')&lt;/code&gt;などと置き換える事もできません。
値の設定（&lt;code&gt;let g:superplugin_default_option = 1&lt;/code&gt;など）は大丈夫です。&lt;/p&gt;
&lt;p&gt;私はこれを回避するために、プラグインを使っている部分を別ファイルに分離してオートコマンドで&lt;code&gt;VimEnter&lt;/code&gt;時に読み込むようにしました。
&lt;code&gt;~/.vim/after/plugin&lt;/code&gt;以下も試してみましたが、ここもパッケージのロードより先に読み込まれていました。
最終的にはプラグインを使う設定を&lt;code&gt;~/.vim/config/plugins.vim&lt;/code&gt;に書いて、次のような設定をvimrcに追加しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; filereadable&lt;span class="p"&gt;(&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/.vim/config/plugins.vim&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  autocmd myvimrc &lt;span class="nb"&gt;VimEnter&lt;/span&gt; * source &lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="sr"&gt;/.vim/&lt;/span&gt;config/plugins.&lt;span class="k"&gt;vim&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これで&lt;code&gt;plugins.vim&lt;/code&gt;の中ではプラグインが使えます。
インストールの確認も&lt;code&gt;if get(g:, 'loaded_~')&lt;/code&gt;や&lt;code&gt;if exists(':PluginCommand')&lt;/code&gt;などでできます。
&lt;code&gt;g:loaded_~&lt;/code&gt;を設定しないプラグインは、とりあえず&lt;code&gt;if match(&amp;amp;runtimepath, 'プラグイン名')&lt;/code&gt;で確認しています。&lt;/p&gt;
&lt;p&gt;注意する点は、オプション値の設定（&lt;code&gt;let g:~~~ = ...&lt;/code&gt;と設定するタイプ）はvimrc内に書いたほうが安全ということです。
読み込み時に設定値のチェックをしてそのまま使っているプラグインが結構あるようで、それらがロードされる前に値の設定を済ませる必要があるからです。&lt;/p&gt;
&lt;h3&gt;読み込まれないプラグイン対策&lt;/h3&gt;
&lt;p&gt;現在は&lt;code&gt;plugin&lt;/code&gt;ディレクトリがないプラグインは読み込まれない（runtimepathに追加されない）ようです。
これはautoload関数だけを提供しているプラグイン（&lt;a href="https://github.com/kana/vim-textobj-user"&gt;textobj-user&lt;/a&gt;など）やカラースキーム（&lt;a href="https://github.com/altercation/vim-colors-solarized"&gt;solalized&lt;/a&gt;など）、スニペット集（&lt;a href="https://github.com/Shougo/neosnippet-snippets"&gt;neosnippet-snippets&lt;/a&gt;）などが該当し、読み込まれません。
これが仕様として確定するのかわかりませんが、私はとりあえずの回避策として&lt;code&gt;mkdir plugin &amp;amp;&amp;amp; touch plugin/_.vim&lt;/code&gt;と適当にファイルを作って置きました。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;plugin&lt;/code&gt;直下に&lt;code&gt;*.vim&lt;/code&gt;ファイルがなく、さらにディレクトリがあるようなプラグインも読み込まれませんでした。
仕様なのか微妙ですが、runtimepathには追加されているのでバグのような気がします。
ありがたいことに&lt;a href="https://github.com/vim-jp/issues/issues/848"&gt;動作確認とIssue報告&lt;/a&gt;までしていただいたので、7.5のリリースまでに修正されるのではないかと。。。
これも上記と同様に適当なファイル（&lt;code&gt;*.vim&lt;/code&gt;）をpluginディレクトリに置くことで読み込み可能です。&lt;/p&gt;
&lt;h2&gt;遅延読み込み&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;opt&lt;/code&gt;以下のプラグインはそのままでは読み込まれません。
&lt;code&gt;:packadd {プラグインのディレクトリ名}&lt;/code&gt;を実行して初めて有効になります。&lt;/p&gt;
&lt;p&gt;私はとりあえずインサートモードで使うプラグインを&lt;code&gt;opt&lt;/code&gt;に置き、以下のような設定を行いました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt; abort
  loadplugin delimitMate
  loadplugin &lt;span class="k"&gt;vim&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;smartchr
  loadplugin ...
  ...
&lt;span class="c"&gt;  &amp;quot; マッピングなどの設定があればする&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; s:init_delimitMate&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;  &amp;quot; 二回目以降実行されないようにautocmdを削除&lt;/span&gt;
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; lazy_load_i
&lt;span class="k"&gt;endfunction&lt;/span&gt;

augroup lazy_load_i
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="nb"&gt;InsertEnter&lt;/span&gt; * &lt;span class="k"&gt;call&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt;
augroup END
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NeoBundleはコマンド実行や関数呼び出しやマッピングをトリガにして遅延読み込みできますが、大変そうだったのでそこまでやっていません。
起動時間に露骨に影響するようなプラグインはそもそも入れてないというのもありますが。
（NERDTreeやsyntasticは読み込みに結構時間かかるので使っていません）&lt;/p&gt;
&lt;h2&gt;起動時間&lt;/h2&gt;
&lt;p&gt;みなさん気になると思います。
ざっくり雑に測っただけですが、とりあえず遅延読み込みしないで全部読み込むような条件ではdein.vimと同じか少し速いくらい、NeoBundleより30~40%速い感じでした。
ただ、上に書いたように読み込まれないプラグインがけっこうあって、気づいたものは対策しましたがまだ読み込まれていないものもありそうなので、実際にはdein.vimと同じくらいじゃないかと思います。&lt;/p&gt;
&lt;p&gt;余談ですが、Vimの起動時間が気になる人は（もしやっていないなら）ファイルタイプの設定を自前で用意してデフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;を読まないようにするといいと思います。
デフォルトの設定だと人生で一度も使わないであろうファイルタイプの設定が大量にあるので。
デフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;は&lt;code&gt;share/vim/vim74/filetype.vim&lt;/code&gt;にあります。
ここから必要そうな設定を拝借してvimrcで設定するなりして、&lt;code&gt;let g:did_load_filetypes=1&lt;/code&gt;しておけばデフォルトのファイルタイプ設定は読まれなくなります。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;NeoBundleがメンテナンスモードに入ると聞いてdein.vimへの移行を考えている方、どうせプラグイン周りの設定をいじるならついでに本体のパッケージ機能も試してみませんか？
いっしょに人柱してバグを探しましょう。&lt;/p&gt;</summary><category term="vim"></category></entry><entry><title>Livemark.vimを色々更新しました</title><link href="https://miyakogi.github.io/blog/20160214/livemark_update.html" rel="alternate"></link><updated>2016-02-14T13:14:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-14:blog/20160214/livemark_update.html</id><summary type="html">&lt;p&gt;Markdown文書をリアルタイムで更新するVimプラグイン、&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;Livemark.vim&lt;/a&gt;を更新しました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+channel&lt;/code&gt;なVimじゃなくても&lt;code&gt;+python&lt;/code&gt;なら動作するので、よければお試し下さい。
安定したものがいい場合は&lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt;などをおすすめします。&lt;/p&gt;
&lt;p&gt;オプションはGitHubの&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;README&lt;/a&gt;に一応全て書いてあります。
まだバグがあるかもしれませんが、その時は&lt;a href="https://github.com/miyakogi/livemark.vim/issues"&gt;Issue&lt;/a&gt;に報告していただけると喜んで対応します。Issueを書くのが面倒でしたら、Twitterで&lt;a href="https://twitter.com/MiyakoDev"&gt;@MiyakoDev&lt;/a&gt;にメンションしていただいても大丈夫です。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h3&gt;変更点&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://h-miyako.hatenablog.com/entry/2016/02/06/135203"&gt;先日の記事&lt;/a&gt;以降に追加した機能（オプション）は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユーザー指定のcss/jsを読み込む設定追加&lt;/li&gt;
&lt;li&gt;シンタックスハイライトのテーマ指定追加&lt;/li&gt;
&lt;li&gt;プレビュー画面のスクロール同期を止めるオプション追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ついでに、Pythonで書かれたプレビュー用のサーバー部分を&lt;a href="https://github.com/miyakogi/livemark"&gt;別リポジトリ&lt;/a&gt;に分離しました。
まだ分離しただけに近い状態ですが、機能を整理してドキュメントやテストを追加して、Vim以外のエディタからも使えるような形にできたらいいなぁ、と思っています。&lt;/p&gt;
&lt;h4&gt;CSS/JSファイルの読み込み&lt;/h4&gt;
&lt;p&gt;デフォルトでは日本語向けBootstrapテーマの&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt;を読み込んでいます。
それに伴い、CDNからjQueryもロードしています。&lt;/p&gt;
&lt;p&gt;ちょっと使うには十分だと思いますが、自分のブログのテーマと同じデザインで使いたいなどの希望があるだろうと考え、CSSやJSを指定できるようにしました。
パスの処理が雑なので、Windowsだと動かないかもしれません。&lt;/p&gt;
&lt;p&gt;指定方法は、例えばCSSを追加してデフォルトのCSSを使わない場合は以下のようになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_css_files &lt;span class="p"&gt;=&lt;/span&gt; [expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/dotfiles/static/css/bootstrap.ja.min.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_no_default_css &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;複数のCSSファイルを指定したい場合はそれぞれリストに追加してください。
リストに追加された順番で読み込みます。
URLを指定すれば（たぶん）Web上のリソースを読み込むこともできます。
その場合はURLを指定してください。
例えば、&lt;code&gt;let g:livemark_css_files = ['https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js']&lt;/code&gt;のような感じです。&lt;/p&gt;
&lt;p&gt;デフォルトのCSSを使用し、CSSを追加したいだけの場合は二行目は不要です。
その場合、ブラウザ上での読み込み順は デフォルトのCSS -&amp;gt; 追加されたCSSの順になります。&lt;/p&gt;
&lt;p&gt;JSについても同様です。各オプションの&lt;code&gt;css&lt;/code&gt;を&lt;code&gt;js&lt;/code&gt;に変更してください。&lt;/p&gt;
&lt;h4&gt;シンタックスハイライトのテーマ設定&lt;/h4&gt;
&lt;p&gt;シンタックスハイライトには&lt;a href="http://pygments.org/"&gt;pygments&lt;/a&gt;を使っています。
デフォルトでは特に指定していないのでpygmentsのデフォルトテーマが使われますが、他にも色々なテーマがあるので変更できるようにしました。&lt;/p&gt;
&lt;p&gt;変更するには以下の設定をvimrcに追加してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_highlight_theme &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;テーマ名&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用可能なテーマはインストールされているpygmentsに依存します。
コマンドラインで確認するには、以下のコマンドを実行して下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -c &lt;span class="s2"&gt;&amp;quot;import pygments.styles; print(pygments.styles.STYLE_MAP.keys())&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示されたキーが利用可能なテーマ名です。
Livemarkのオプションで特定のpythonを指定している場合はpython3の部分をそちらに変えてください。&lt;/p&gt;
&lt;h4&gt;スクロールの同期を止めるオプションの追加&lt;/h4&gt;
&lt;p&gt;デフォルトではVimのカーソル位置に応じて画面をスクロールしています。
具体的には、Vimのバッファに表示されている最初の行が画面の最上部に来るように調整しています。&lt;/p&gt;
&lt;p&gt;とはいえ、MarkdownからHTMLに変更する時に行番号がずれてしまうので、一応頑張って調整していますが完璧ではありません。
また、書いている時に動かない方がいい場合もあるかと思います。&lt;/p&gt;
&lt;p&gt;ということで、以下のオプションでスクロールを停止できます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_disable_scroll &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内部的な話&lt;/h3&gt;
&lt;p&gt;内部的にはかなり大きな変更を行いました。&lt;/p&gt;
&lt;p&gt;当初はカーソル移動やテキストの編集が行われるたびに全文をhtmlにパースし、プレビュー画面全部を書き換えるという力技で実装されていたのですが、さすがにこれだと大きなファイルの時に描画の遅れが深刻だったので修正しました。
今は差分を検出して変更のあった部分だけを更新しています。
個人的にはJSツラいのでJSではなくPythonで処理しました。&lt;/p&gt;
&lt;p&gt;ちょうど今&lt;a href="https://github.com/miyakogi/wdom_py"&gt;wdom&lt;/a&gt;というPythonからブラウザ上のDOMを操作するライブラリを開発しているので、これを使ってHTMLからDOMにパースして変更箇所だけをブラウザ上で変更、という処理にしています。Livemark用のJSはスクロール用の関数を数行書いただけで、他はPythonで実装できました。変更がない時はHTMLへの変換も行わないので、カーソル移動はかなりスムーズになったと思います。&lt;/p&gt;
&lt;p&gt;なお、このライブラリ（wdom）は絶賛開発途中です。
Livemarkにバグがあっても「まぁ、そういう時もあるよね」という温かい心で接してください。&lt;/p&gt;
&lt;p&gt;ちなみに、wdomで目指すところはほぼJSフリーでelectron/ブラウザを使ったGUIアプリの開発です。
昨年からelectronが流行ってますけど、JSでデスクトップアプリ作りたい人だけじゃなくて、CSSフレームワーク（Bootstrapとか）のために渋々JS書いてる人も多いんじゃないの？というのが開発の動機です。
&lt;s&gt;つまり既存のGUIライブラリは見た目が残念・・・&lt;/s&gt;
今はLivemarkで色々使ってみて、必要な機能の確認とバグを洗い出している感じです。
なのでまだドキュメントもありませんし、APIも変わる可能性があります。
落ち着いたらPyPIに登録して &lt;strong&gt;「まだじゃわすくりぷとで消耗しているの？」&lt;/strong&gt; 的な煽りタイトルの記事を書きたいと思っています。
ヘタれたらもっと穏便なタイトルにするので優しくしてください。&lt;/p&gt;
&lt;p&gt;以上です。
開発中のものを色々取り入れているのでバグがある可能性大ですが、人柱精神旺盛な方、よろしければお試しください。&lt;/p&gt;</summary><category term="vim"></category><category term="python"></category></entry><entry><title>Vim の channel と json のパフォーマンス</title><link href="https://miyakogi.github.io/blog/20160206/channel1.html" rel="alternate"></link><updated>2016-02-06T10:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-06:blog/20160206/channel1.html</id><summary type="html">&lt;p&gt;先日公開した &lt;a href="https://github.com/miyakogi/livemark.vim"&gt;livemark.vim&lt;/a&gt; には想像以上にたくさんの反響をいただきました。
ありがとうございます。
最近では海外の方からもGithubのスターをいただきました。
思いつきで作ったプラグインでしたが、せっかくなので普段使いできるようにいくつか更新しました。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;ul&gt;
&lt;li&gt;channel をサポートしない vim では python を使うように修正&lt;ul&gt;
&lt;li&gt;channelをサポートするvimでもpythonを使いたい場合は &lt;code&gt;let g:livemark_force_pysocket=1&lt;/code&gt; で使えます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;マークダウンの変換及びプレビュー表示をするpythonを指定する設定追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_python='/path/to/python'&lt;/code&gt; で指定できます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビューを表示するブラウザを vim から設定できるように修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_browser='[ブラウザ名]'&lt;/code&gt; で設定できます&lt;/li&gt;
&lt;li&gt;設定可能なブラウザと名前は&lt;a href="http://docs.python.jp/3/library/webbrowser.html#webbrowser.register"&gt;ここ&lt;/a&gt;を参照してください&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビュー表示に使うポートと vim からデータを送るために使うポートの設定を追加&lt;ul&gt;
&lt;li&gt;それぞれ &lt;code&gt;g:livemark_browser_port&lt;/code&gt; と &lt;code&gt;g:livemark_vim_port&lt;/code&gt; です&lt;/li&gt;
&lt;li&gt;デフォルト値はそれぞれ 8089, 8090 です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とはいえ、まだ安定しているとは言いがたい状態なので、マークダウンのプレビューには &lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt; などを使うのがいいと思います。&lt;/p&gt;
&lt;p&gt;今の実装だと変更がある度に画面全体を再描画していて大きいファイルのプレビューは厳しいので、差分だけ更新するような処理を実装中です。&lt;/p&gt;
&lt;p&gt;そんな感じで地味に更新したりしてたのですが、&lt;a href="http://ftp.vim.org/vim/patches/7.4/7.4.1244"&gt;このパッチ&lt;/a&gt;でchannel関係の関数名が全部変わったので動かなくなりました（つらい&lt;/p&gt;
&lt;p&gt;&lt;img alt="channel error" src="https://miyakogi.github.io/blog/images/channel_error.png" /&gt;&lt;/p&gt;
&lt;p&gt;修正してもまた仕様変更あったら面倒だなぁ、と微妙にやる気が減退気味だったのと、pythonでデータ送ってもそんなにもたつきを感じなかったりして「もしかして Vim の channel より python の方が速い・・・？いや channel も json も C で書かれてるしそんなはずは・・・でも Vim だし何が起きるかわからん」という疑問が沸き起こったので測ってみました。&lt;/p&gt;
&lt;p&gt;Livemark.vim では編集中のバッファの文字列を取得して json として送っているので、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;データをjsonに変換する処理&lt;/li&gt;
&lt;li&gt;変換されたデータをサーバーに送りつける処理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;に分けて計測しました。また、Vimは一旦jsonに変換してから送る場合 (raw channel) とjsonへの変換も一気に行う場合 (json channel) の両方を測りました。&lt;/p&gt;
&lt;p&gt;データを送りつけられるサーバーがボトルネックになると意味ないので、サーバーは Nim で書きました。 サーバーのコードはこんな感じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;nativesockets&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;net&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bindAddr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;accepted&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;connection closed&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;

&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ベンチマークのコードはこんな感じ&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;scriptencoding&lt;/span&gt; utf&lt;span class="m"&gt;-8&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; s:data &lt;span class="p"&gt;=&lt;/span&gt; readfile&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;EOF
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;vim&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s:data&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_vim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsonencode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_raw&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;raw&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_sendraw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="c1"&gt;# data = json.dumps(vim.eval(&amp;#39;s:data&amp;#39;)).encode(&amp;#39;utf-8&amp;#39;)&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_connection&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
EOF
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;let&lt;/span&gt; handler &lt;span class="p"&gt;=&lt;/span&gt; ch_open&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; {&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;: &lt;span class="s1"&gt;&amp;#39;json&amp;#39;&lt;/span&gt;}&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_sendexpr&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;,&lt;/span&gt; s:data&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_close&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;py_eval:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_vim&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_vim:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_py:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_raw&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;raw_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;python:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;data.txt&lt;/code&gt; には &lt;code&gt;This is sample data\n\n&lt;/code&gt; が10万回、合計20万行入っています。
Pythonの場合は Vim で読み込んだデータを python に渡す処理も入ってくるので、そこは別で計測しています。&lt;/p&gt;
&lt;p&gt;結果はこうなりました。（単位は秒、Vim のバージョンは 7.4.1265 です）&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;vim (json)&lt;/th&gt;
&lt;th&gt;vim (raw)&lt;/th&gt;
&lt;th&gt;python&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vim -&amp;gt; py&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.165894&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;json化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.496177&lt;/td&gt;
&lt;td&gt;0.300104&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;データ送信&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.023818&lt;/td&gt;
&lt;td&gt;0.087396&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;合計&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.519995&lt;/td&gt;
&lt;td&gt;0.553394&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合計あまり変わらない・・・&lt;s&gt;Pythonよりは速くて「channelすごい！jsonすごい！」って記事になる予定だったのに・・・・&lt;/s&gt;jsonのエンコードにすごい時間かかってますね・・・よく考えたら、一度Vim scriptになってるのでむしろよく頑張ってる方だと思います。
「あれ、たしかpython標準のjsonモジュールって・・・」って&lt;a href="http://postd.cc/memory-use-and-speed-of-json-parsers/"&gt;などの疑問&lt;/a&gt;を持ってはいけません。&lt;/p&gt;
&lt;p&gt;というわけで！Pythonで処理してもあまりパフォーマンスに影響なさそうなので！むしろ20万行のマークダウンとか書かないと思うので！channelの仕様変更に負けずに地味に更新していきたいと思います！レッツポジティブ！&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>Vim に channel が実装されたので Markdown をプレビューするプラグインを作りました</title><link href="https://miyakogi.github.io/blog/20160129/livemark1.html" rel="alternate"></link><updated>2016-01-29T19:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-01-29:blog/20160129/livemark1.html</id><summary type="html">&lt;p&gt;Vimにchannel機能が実装されました。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mattn.kaoriya.net/software/vim/20160129114716.htm"&gt;Big Sky :: Vim にchannel(ソケット通信機能)が付いた。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨日から株価・為替は乱高下し、大臣の辞任、日銀のマイナス金利導入決定など国内では大きなニュースが続いていますが、Vimmerにとってはこのパッチが最も影響があったのではないでしょうか。&lt;/p&gt;
&lt;p&gt;というわけで、せっかくなのでchannel機能を使ってプラグインを書いてみました。
みんな大好きMarkdownのリアルタイムプレビューです。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;miyakogi/livemark.vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;channelを使ってみたかっただけなので、今のところデバッグ・エラー処理・設定などはやっつけです。
お遊び以外では使わないでください。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;インストール方法は普通のvimプラグインと同じです。コピーするなりプラグインマネージャを使うなり、お好みの方法でインストールしてください。&lt;/p&gt;
&lt;p&gt;NeoBundleをお使いの場合は &lt;code&gt;NeoBundle 'miyakogi/livemark.vim'&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;残念ながらVimはまだmarkdownの変換やwebサーバーなどの機能はないので、その辺りはPythonで処理しています。 以下のようにpythonのライブラリを別途インストールして下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install misaka pygments tornado
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pygments はコードのシンタックスハイライトに使っています。&lt;/p&gt;
&lt;p&gt;Vimのpythonではなく外部プロセスでpythonを起動しているので、vimは&lt;code&gt;+python3&lt;/code&gt;でなくても動きます。&lt;code&gt;vimproc&lt;/code&gt;もなくて大丈夫です。&lt;/p&gt;
&lt;p&gt;Pythonのバージョンは3.5で確認していますが、たぶん3.4でも動くと思います。&lt;/p&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;Vimで適当なmarkdownファイルを開き、&lt;code&gt;:LiveMark&lt;/code&gt;を実行してください。するとchromeが起動しますので、vimでファイルを編集したりカーソルを動かしたりしてみてください。リアルタイムで変更がブラウザ上に反映されるはずです。&lt;/p&gt;
&lt;p&gt;また、Vim上のカーソル位置も取得していますので、長い文章でブラウザの画面に収まらない場合、カーソル位置が画面に収まるようにいい感じ（自称）にスクロールします。&lt;/p&gt;
&lt;p&gt;スタイルが何もないと寂しいので、&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt; という日本語向けの Bootstrap テーマを同梱させていただきました&lt;sup id="fnref:honoka-cdn"&gt;&lt;a class="footnote-ref" href="#fn:honoka-cdn" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。日本語でもきれいに表示されると思います。&lt;/p&gt;
&lt;p&gt;終了する時は&lt;code&gt;:LiveMarkDisable&lt;/code&gt;です。何もしなくてもVimが終了した時にサーバープロセスは止まります。&lt;/p&gt;
&lt;h4&gt;手抜き感の漂うスクリーンキャスト・・・&lt;/h4&gt;
&lt;p&gt;&lt;img alt="screen cast" src="https://miyakogi.github.io/blog/images/livemark_sample.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;諸注意&lt;/h2&gt;
&lt;p&gt;エラーなどでPythonのプロセスが残ってしまう場合があります。その時はプロセスを殺してください。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:honoka-cdn"&gt;
&lt;p&gt;HonokaのCDNがわからなかったのでコードを含めています。
ライセンスはMITとのことなので大丈夫だとは思いますが、もし不都合ありましたらご一報ください。&amp;#160;&lt;a class="footnote-backref" href="#fnref:honoka-cdn" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Python"></category><category term="Vim"></category></entry></feed>