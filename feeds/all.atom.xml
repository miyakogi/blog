<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Blank File</title><link href="https://miyakogi.github.io/blog/" rel="alternate"></link><link href="https://miyakogi.github.io/blog/feeds/all.atom.xml" rel="self"></link><id>https://miyakogi.github.io/blog/</id><updated>2016-04-06T20:00:00+09:00</updated><entry><title>PythonでブラウザベースのGUIアプリを作るライブラリ、WDOMの紹介</title><link href="https://miyakogi.github.io/blog/20160406/wdom_intro.html" rel="alternate"></link><updated>2016-04-06T20:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-04-06:blog/20160406/wdom_intro.html</id><summary type="html">&lt;p&gt;WDOMというPythonでブラウザベースのGUIアプリを作るためのライブラリを作っています。
ちょっとしたGUIツールを作ろうと思った時に満足できるものがなかったので作りました。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom"&gt;miyakogi/wdom: DOM manipulation library for python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WDOMのターゲットは、あくまでブラウザベースのデスクトップGUIアプリです。
ローカルにWebサーバを立ち上げてブラウザ上に表示しますが、Webフレームワークではありません。
ちなみに、拙作&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;LiveMark.vim&lt;/a&gt;もこれを使っています。&lt;/p&gt;
&lt;p&gt;まだ開発中なので細かいバグはあると思いますし、後方互換性を崩すような変更が入る可能性もありますが、そろそろ試してもらえるくらいにはなってきたので使い方を中心に紹介します。&lt;/p&gt;
&lt;p&gt;もしバグを発見したら&lt;a href="https://github.com/miyakogi/wdom/issues"&gt;GitHubのIssue&lt;/a&gt;に報告していただけると助かります。
（できれば英語でお願いします（難しければタイトルだけでも））&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;動機&lt;/h2&gt;
&lt;p&gt;PythonのGUIライブラリだと標準ライブラリのTkInterやPyQt、wxPythonなどが有名で、私はPyQtを結構使っていましたが、以下の不満もありました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;見た目が残念（他よりマシですが、今となっては・・・）&lt;ul&gt;
&lt;li&gt;スタイルの変更は一応可能ですが面倒です&lt;/li&gt;
&lt;li&gt;いい感じのCSSを読み込んでクラス指定くらいで済ませたいです&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;インストールが大変&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip install PyQt&lt;/code&gt;では今の所インストールできません&lt;/li&gt;
&lt;li&gt;anacondaなどで楽できるらしいですが好きじゃないです&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配布可能なバイナリパッケージにするのもそれなりに面倒&lt;ul&gt;
&lt;li&gt;だいぶ記憶が薄れてしまいましたが、いくつかはまった記憶があります&lt;ul&gt;
&lt;li&gt;特にWindows・・・&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;情報が少ない&lt;ul&gt;
&lt;li&gt;結局qtのリファレンスを読みながら使っていました&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テストしにくい&lt;ul&gt;
&lt;li&gt;UIが絡むテストも&lt;a href="http://johnnado.com/pyqt-qtest-example/"&gt;できるらしい&lt;/a&gt;ですが&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ライセンスがGPL&lt;ul&gt;
&lt;li&gt;自分が使う分には問題ありませんが、やっぱりもっとゆるいライセンスが気持ち的に安心です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特徴&lt;/h2&gt;
&lt;p&gt;ということで、WDOMは上記の不満をそれなりに解消するために作りました。&lt;/p&gt;
&lt;p&gt;ブラウザ上に表示するので各種CSSライブラリなどはそのまま使えますし、メソッド名などもDOMと同じなので学習コスト低め（調べたことが無駄になりにくい）です。
基本的には、PyQtでよく使う機能はDOMで実現できるでしょたぶん、という方針です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ブラウザ上に表示するので、巷に溢れるCSSフレームワークが利用可能&lt;ul&gt;
&lt;li&gt;Bootstrap万歳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;必須ライブラリはtornadoだけ、かつpure python実装なのでインストールはpipでOK&lt;/li&gt;
&lt;li&gt;配布可能なバイナリにするのも通常のpythonで書かれたパッケージと（だいたい）同じ方法でOK&lt;/li&gt;
&lt;li&gt;インターフェイスはDOM仕様に基づいているので、メソッド名や引数のとり方などは&lt;a href="https://developer.mozilla.org/ja/docs/Web/API"&gt;MDN&lt;/a&gt;などで確認可能&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Element.appendChild(追加したい要素)&lt;/code&gt; で追加とかする感じです&lt;ul&gt;
&lt;li&gt;イベントの処理は&lt;code&gt;Element.addEventListener('click', 関数)&lt;/code&gt;です&lt;/li&gt;
&lt;li&gt;実装済みの機能は&lt;a href="https://github.com/miyakogi/wdom/wiki/Features"&gt;こちら&lt;/a&gt;をご参照ください&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JavaScriptでDOMを触ったことがあればなんとなくわかると思います&lt;/li&gt;
&lt;li&gt;JavaScriptを触ったことがなくても、今後触る機会があるかもしれないので、覚えたことは無駄になりにくいです&lt;/li&gt;
&lt;li&gt;まだブラウザに実装されていない最新のDOM仕様も一部実装しています&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/ChildNode"&gt;ChildNode&lt;/a&gt;のbefore/afterや&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/ParentNode"&gt;ParentNode&lt;/a&gt;のappend/prependなど&lt;/li&gt;
&lt;li&gt;Custom Elementsも一応実装しています&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://selenium-python.readthedocs.org/"&gt;Selenium&lt;/a&gt;でUIのテストが可能&lt;ul&gt;
&lt;li&gt;Seleniumもブラウザ上でテストを実行する汎用的なライブラリなので、覚えたことは無駄になりにくいです&lt;/li&gt;
&lt;li&gt;HTMLを出力して確認することもできます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ライセンスはMITです&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;類似のプロジェクトでは&lt;a href="https://github.com/zoofIO/flexx"&gt;flexx&lt;/a&gt;や&lt;a href="http://www.reahl.org/"&gt;Reahl&lt;/a&gt;などがありましたが、これらはそれなりに学習コストが高そう＆Webフレームワークっぽかったので見送りました。&lt;/p&gt;
&lt;h2&gt;必要環境&lt;/h2&gt;
&lt;p&gt;Python3.5.1以上（つまり現在の最新版のみ）の対応です。
オプションのaiohttpを使わなければ3.4.4でも動くかもしれません。
あと、おそらく大丈夫だとは思いますが、Windows環境ではテストしていません。&lt;/p&gt;
&lt;p&gt;ブラウザ上に表示するのでブラウザが必要です。
逆に言えば、Pythonが動作してブラウザがある環境であれば動作します。
当然ですがIEはサポート対象外です。
とはいえ、ほとんどの機能は動作すると思います。
ブラウザはElectronやPyQtのブラウザなどでも大丈夫です（たぶん）。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;普通にpipでインストールできます。&lt;/p&gt;
&lt;p&gt;PyPIに登録しようかと思ったのですが、まだ細かいバグがありそうだったので見送りました。
近いうちに登録したいとは考えています。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install git+http://github.com/miyakogi/wdom
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Webフレームワークの&lt;a href="http://www.tornadoweb.org/en/stable/"&gt;tornado&lt;/a&gt;に依存しているので一緒にインストールされます。
オプションで&lt;a href="http://aiohttp.readthedocs.org/en/stable/"&gt;aiohttp&lt;/a&gt;を使うこともできます。
こちらはネイティブでasyncioに対応していますし、C拡張で書かれているので（たぶん）パフォーマンス的にも優位だと思います。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install aiohttp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;aiohttpがインストールされていれば勝手にそっちを使うので、特別な設定は必要ありません。&lt;/p&gt;
&lt;h2&gt;基本的な使い方&lt;/h2&gt;
&lt;p&gt;とりあえず "Hello, WDOM" と表示するだけのプログラムは以下のようになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.misc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;install_asyncio&lt;/span&gt; &lt;span class="c1"&gt;# tornadoを使う時だけ必要です&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.server&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stop_server&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.document&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;install_asyncio&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# tornadoを使う時だけ必要です&lt;/span&gt;

    &lt;span class="n"&gt;document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;# documentオブジェクトを取得&lt;/span&gt;
    &lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;#39;h1&amp;#39; タグを作る&lt;/span&gt;
    &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello, WDOM&amp;#39;&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;#39;h1&amp;#39; タグの文字列を指定&lt;/span&gt;
    &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;#39;body&amp;#39; タグに &amp;#39;h1&amp;#39; タグを挿入&lt;/span&gt;

    &lt;span class="c1"&gt;# 以下はテンプレだと思って下さい&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_app&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_event_loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start_server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8888&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# webサーバのportを8888に指定&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_forever&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;stop_server&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut1.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;このプログラムを実行して、ブラウザで&lt;code&gt;http://localhost:8888&lt;/code&gt;にアクセスすると "Hello, WDOM" と表示されるはずです。&lt;/p&gt;
&lt;p&gt;重要な部分は &lt;code&gt;document = get_document()&lt;/code&gt; 以下の4行です。
ほぼJavaScriptでDOMを操作する時と同じになっています。
要素の追加は&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/appendChild"&gt;appendChild&lt;/a&gt;や&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/insertBefore"&gt;insertBefore&lt;/a&gt;、&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/replaceChild"&gt;replaceChild&lt;/a&gt;などで行えます。
&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/removeChild"&gt;removeChild&lt;/a&gt;で削除することも可能です。&lt;/p&gt;
&lt;p&gt;「&lt;code&gt;document.createElement&lt;/code&gt; とか面倒」と感じると思いますが、ショートカットは用意してあるのでご安心下さい（後述します）。
また、ここでは&lt;code&gt;appendChild&lt;/code&gt;で要素を追加していますが、&lt;a href="https://dom.spec.whatwg.org/"&gt;最新の仕様&lt;/a&gt;に含まれている&lt;code&gt;append&lt;/code&gt;や&lt;code&gt;after&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;なども実装してあります。&lt;/p&gt;
&lt;h2&gt;DOMについて&lt;/h2&gt;
&lt;p&gt;WDOMで扱うUI部品はすべてブラウザ上のタグ（要素）に相当します。
WDOMの各要素はブラウザ上のタグと一対一の関係を持っています。&lt;/p&gt;
&lt;p&gt;例えば、上の例で作った&lt;code&gt;h1&lt;/code&gt;要素（&lt;code&gt;docuemnt.createElement('h1')&lt;/code&gt;で作られたインスタンス）はブラウザ上のh1タグ、すなわち&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;というHTMLの要素になります。
WDOMのUI部品はHTMLで表現することができ、実際にブラウザ上で表示されるHTMLは&lt;code&gt;html&lt;/code&gt;属性で取得することができます。
先ほどの&lt;code&gt;h1&lt;/code&gt;要素であれば&lt;code&gt;print(h1.html)&lt;/code&gt;とすることで実際のHTMLを確認できます。&lt;/p&gt;
&lt;p&gt;これらの要素はDOMで規定されている各種メソッドも備えているので、JavaScriptでDOMを扱う時と同じように要素の追加・削除などを行うことができます。&lt;/p&gt;
&lt;p&gt;この節では基本的なDOM操作について説明します。
ブラウザ上のJavaScriptとほとんど同じなので、そちらをご存じの方は読み飛ばしてください。
WDOMに実装済みの機能の一覧は&lt;a href="https://github.com/miyakogi/wdom/wiki/Features"&gt;こちら&lt;/a&gt;をご参照下さい。
正式なドキュメント（APIリファレンス）はまだ用意出来ていません、申し訳ありません。&lt;/p&gt;
&lt;h3&gt;要素の作成&lt;/h3&gt;
&lt;p&gt;WDOMで要素を新規に作成する方法は、大別して以下の三種類の方法があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docuemnt.createElement&lt;/code&gt; メソッドでタグ名を指定して作成&lt;/li&gt;
&lt;li&gt;各要素の&lt;code&gt;innerHTML&lt;/code&gt;や&lt;code&gt;insertAdjacentHTML&lt;/code&gt;でHTMLから作成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wdom.tag&lt;/code&gt;モジュールで定義されている各クラスから作成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作成された要素は、&lt;code&gt;document&lt;/code&gt;をルートとするDOMツリーに追加されるまでは表示されません。
ただし、&lt;code&gt;innerHTML&lt;/code&gt;や&lt;code&gt;insertAdjacentHTML&lt;/code&gt;では作成と同時にその要素の子要素として追加されます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Document/createElement"&gt;document.createElement  MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/innerHTML"&gt;element.innerHTML MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/insertAdjacentHTML"&gt;element.insertAdjacentHTML MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;要素の追加&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;appendChild&lt;/code&gt;や&lt;code&gt;insertBefore&lt;/code&gt;メソッドで要素をDOMツリーに追加することができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;親要素.appendChild(追加する要素)&lt;/code&gt;では、親要素の最後の子要素として&lt;code&gt;追加する要素&lt;/code&gt;が追加されます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;親要素.insertBefore(追加する要素, 追加したい位置の要素)&lt;/code&gt;では、&lt;code&gt;追加したい位置の要素&lt;/code&gt;の直前に&lt;code&gt;追加する要素&lt;/code&gt;が挿入されます。
&lt;code&gt;追加したい位置の要素&lt;/code&gt;は親要素の直接の子要素でなくてはなりません。&lt;/p&gt;
&lt;p&gt;追加された要素がすでに別の親要素を持っていた場合、その親要素からは自動的に取り除かれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/appendChild"&gt;Node.appendChild MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/insertBefore"&gt;Node.insertBefore MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;要素の削除&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;removeChild&lt;/code&gt;メソッドで特定の子要素を削除することができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;親要素.removeChild(子要素)&lt;/code&gt;とすることで、子要素は親要素から取り除かれます。
この時、取り除かれる子要素は親要素の直接の子要素でなくてはなりません。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/removeChild"&gt;Node.removeChild MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;要素の入れ替え&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;replaceChild&lt;/code&gt;メソッドで要素子要素を入れ替えることができます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;親要素.replaceChild(挿入する要素, 取り除く要素)&lt;/code&gt;とすることで、&lt;code&gt;取り除く要素&lt;/code&gt;が&lt;code&gt;挿入する要素&lt;/code&gt;と置き換えられます。
この時、&lt;code&gt;取り除く要素&lt;/code&gt;は親要素の直接の子要素でなくてはなりません。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/replaceChild"&gt;Node.replaceChild MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;親要素へのアクセス&lt;/h3&gt;
&lt;p&gt;ある要素の親要素には&lt;code&gt;要素.parentNode&lt;/code&gt;属性でアクセスできます。
要素がまだDOMツリーに追加されておらず、親要素が存在しない場合は&lt;code&gt;None&lt;/code&gt;を返します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/parentNode"&gt;Node.parentNode MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;子要素へのアクセス&lt;/h3&gt;
&lt;p&gt;ある要素の子要素には&lt;code&gt;要素.childNodes&lt;/code&gt;属性でアクセスできます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;childNodes&lt;/code&gt;属性で返されるオブジェクトはリスト風の&lt;strong&gt;Live Object&lt;/strong&gt;です。
Pythonのリスト同様、&lt;code&gt;for child in 要素.childNodes:&lt;/code&gt;という形でループを介してアクセスしたり、&lt;code&gt;childNodes[i]&lt;/code&gt;という形でインデックスアクセスしたり、&lt;code&gt;if child in parent.childNodes:&lt;/code&gt;などの形で特定の要素が含まれているか確認することができます。&lt;/p&gt;
&lt;p&gt;ただし、通常のリストとは異なり、直接要素を追加したり削除したりすることはできません。
また、&lt;strong&gt;Live Object&lt;/strong&gt;なので、親要素の変更が常時反映されます。
そのため、以下のようなコードは無限ループになってしまいます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;docuemnt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;div&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;docuemnt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;p&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;child_nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;childNodes&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;child_nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;p&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先頭の子要素、あるいは末尾の子要素には&lt;code&gt;要素.firstChild&lt;/code&gt;や&lt;code&gt;要素.lastChild&lt;/code&gt;でアクセスすることもできます。
子要素が存在しない場合、これらは&lt;code&gt;None&lt;/code&gt;を返します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/childNodes"&gt;Node.childNodes MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/firstChild"&gt;Node.firstChild MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/lastChild"&gt;Node.lastChild MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;隣接ノードへのアクセス&lt;/h3&gt;
&lt;p&gt;隣接するノードには&lt;code&gt;nextSibling&lt;/code&gt;や&lt;code&gt;previousSibling&lt;/code&gt;でアクセスできます。
親要素を持たない場合、または要素が先頭・末尾にあって該当する要素が存在しない場合は&lt;code&gt;None&lt;/code&gt;を返します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/nextSibling"&gt;Node.nextSibling MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Node/previousSibling"&gt;Node.previousSibling MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;属性値へのアクセス&lt;/h3&gt;
&lt;p&gt;各要素にはHTML同様に属性値を設定することができます。
HTMLの&lt;code&gt;&amp;lt;a href="http://......./"&amp;gt;リンク&amp;lt;/a&amp;gt;&lt;/code&gt;における&lt;code&gt;href=""&lt;/code&gt;に相当する部分です。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getAttribute('属性名')&lt;/code&gt;で取得、&lt;code&gt;setAttribute('属性名', '値')&lt;/code&gt;で設定、&lt;code&gt;removeAttribute('属性名')&lt;/code&gt;で削除できます。
存在しない属性に対して&lt;code&gt;getAttribute&lt;/code&gt;を行うと&lt;code&gt;None&lt;/code&gt;が返されます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Attr"&gt;Attr MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/getAttribute"&gt;element.getAttribute MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/setAttribute"&gt;element.setAttribute MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute"&gt;Element.removeAttribute() MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/NamedNodeMap"&gt;NamedNodeMap MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;使用例&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;docuemnt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;リンク&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;href&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# &amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;リンク&amp;lt;/a&amp;gt;`&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;href&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# &amp;#39;/&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;removeAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;href&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;href&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;各要素に設定されている属性の一覧は&lt;code&gt;要素.attributes&lt;/code&gt;で取得することができます。
この時返されるオブジェクトは&lt;code&gt;{'属性名': Attrノード, ...}&lt;/code&gt;の辞書風オブジェクト（NamedNodeMap）です。&lt;/p&gt;
&lt;h4&gt;特殊な属性値&lt;/h4&gt;
&lt;p&gt;一部の属性値は、要素の属性として直接アクセスすることができます。&lt;/p&gt;
&lt;p&gt;例えば&lt;code&gt;id&lt;/code&gt;属性は&lt;code&gt;要素.id&lt;/code&gt;で取得したり&lt;code&gt;要素.id = 'some_id'&lt;/code&gt;で設定することができます。
&lt;code&gt;id&lt;/code&gt;属性が設定されていない状態で&lt;code&gt;要素.id&lt;/code&gt;を取得すると空文字列が返ります。
返り値の型は属性によって異なり、例えば&lt;code&gt;hidden&lt;/code&gt;属性は&lt;code&gt;True&lt;/code&gt;または&lt;code&gt;False&lt;/code&gt;を返しますし、&lt;code&gt;style&lt;/code&gt;属性は&lt;code&gt;CSSStyleDeclaration&lt;/code&gt;のインスタンスを返します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/HTMLElement"&gt;HTMLElement&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;WDOMではまだ全ての属性値が実装できてはいません&lt;/li&gt;
&lt;li&gt;実際の実装状況は&lt;a href="https://github.com/miyakogi/wdom/wiki/Features"&gt;こちら&lt;/a&gt;の&lt;code&gt;interface Element&lt;/code&gt;以下をご参照ください&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/id"&gt;element.id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/HTMLElement/style"&gt;element.style&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;イベント&lt;/h3&gt;
&lt;p&gt;イベント処理の追加には&lt;code&gt;addEventListener&lt;/code&gt;メソッドを使用します。
実際に動かしたほうがわかりやすいと思うので、最初のサンプルコードをベースに説明します。&lt;/p&gt;
&lt;h4&gt;クリック時に文字列反転&lt;/h4&gt;
&lt;p&gt;上記のサンプルコードで、&lt;code&gt;h1.textContent = ...&lt;/code&gt; の次の行に以下のコードを追加してみてください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rev_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# h1の中身の文字列を反転&lt;/span&gt;
        &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;click&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rev_text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# rev_textには括弧なしです！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut2.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h1&lt;/code&gt;要素がクリックされた時に文字列が反転するはずです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addEventListener&lt;/code&gt;の第一引数が反応するイベントの種類（文字列）、第二引数がそのイベントが発火した時に実行される処理（関数、イベントリスナー）になります。
&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener"&gt;JavaScriptの場合と同じ&lt;/a&gt;です。
今回はクリックされた時に&lt;code&gt;rev_text&lt;/code&gt;関数を実行し、h1要素の中身の文字列を反転させています。
&lt;code&gt;rev_text&lt;/code&gt;関数には&lt;code&gt;Event&lt;/code&gt;オブジェクトが渡されますが、今回は使っていません。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget/addEventListener"&gt;EventTarget.addEventListener MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ユーザー入力の取得&lt;/h4&gt;
&lt;p&gt;ユーザーからの入力を取得したい場合は、&lt;code&gt;input&lt;/code&gt;要素または&lt;code&gt;textarea&lt;/code&gt;要素を使います。
input要素に入力された文字列を、先ほどのh1要素に表示してみます。&lt;/p&gt;
&lt;p&gt;以下のように変更してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;h1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello, WDOM&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
    &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut3.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文字列を入力すると "Hello, WDOM" と表示されていた部分が置き換えられるはずです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;update&lt;/code&gt;関数内でアクセスしている&lt;code&gt;event.target&lt;/code&gt;は、イベントが発火したオブジェクトへの参照（この場合はinput要素）です。
&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/HTMLInputElement"&gt;input要素&lt;/a&gt;は現在の入力値を&lt;code&gt;value&lt;/code&gt;属性に保持しているので、それをh1要素の&lt;code&gt;textContent&lt;/code&gt;に設定しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;event&lt;/code&gt;オブジェクトもDOMの&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Event"&gt;Event&lt;/a&gt;オブジェクトと同じ構造をしているので、詳細は仕様を確認してください。
（まだ&lt;a href="https://github.com/miyakogi/wdom/wiki/Features#events"&gt;実装できていない部分&lt;/a&gt;も多いですが・・・特にイベントの伝播制御は全く手付かずです・・・）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Event"&gt;event MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/en-US/docs/Web/Events"&gt;Event reference MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;イベントリスナーの削除&lt;/h4&gt;
&lt;p&gt;登録したイベントリスナーを削除する場合は&lt;code&gt;removeEventListener&lt;/code&gt;を使います。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addEventListener&lt;/code&gt;同様、&lt;code&gt;removeEventListener(イベントの種類, イベントリスナー)&lt;/code&gt;の形で呼び出し、イベントの種類とイベントリスナーの両方が一致した時にそのイベントリスナーが取り除かれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/EventTarget/removeEventListener"&gt;EventTarget.removeEventListener MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Pythonのクラスの利用&lt;/h2&gt;
&lt;p&gt;毎回&lt;code&gt;createElement&lt;/code&gt;をするのはとてつもなく面倒ですし、documentへの参照が必要で不便極まりないので、クラスから直接要素を作れるようにしてあります。
以下の機能は&lt;a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/"&gt;BeautifulSoup&lt;/a&gt;を参考にしました。&lt;/p&gt;
&lt;p&gt;例えば、先ほどのh1要素とinput要素を子要素に持つdiv要素を作る場合は以下のようにできます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;# h1要素を新しく作成&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello, WDOM&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;# input要素を新しく作成&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# 省略&lt;/span&gt;

    &lt;span class="n"&gt;document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyElement&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# 以下同じ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut4.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom/blob/dev/wdom/tag.py"&gt;wdom.tagモジュール&lt;/a&gt;には一般的なタグを表すクラスが一通り定義してあります。
全てタグ名の一文字目が大文字で他は小文字というクラス名です。&lt;/p&gt;
&lt;p&gt;例えば&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;タグは&lt;code&gt;wdom.tag.Button&lt;/code&gt;で&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;タグは&lt;code&gt;wdom.tag.Br&lt;/code&gt;です。
例外はありません。
&lt;code&gt;textarea&lt;/code&gt;も&lt;code&gt;wdom.tag.Textarea&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;上記の&lt;code&gt;MyElement&lt;/code&gt;クラスのように、既存のクラスを継承して独自のクラスを作ることもできます。
&lt;code&gt;MyElement&lt;/code&gt;クラスは&lt;code&gt;Div&lt;/code&gt;クラスを継承しているので、そのインスタンスはブラウザ上では&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;要素として表示されます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(MyElement().html)&lt;/code&gt;とすると実際のhtmlが取得できます。
この場合、以下のようになっているはずです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt; &lt;span class="na"&gt;rimo_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;数値〜&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;input&lt;/span&gt; &lt;span class="na"&gt;rimo_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;数値〜&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt; &lt;span class="na"&gt;rimo_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;数値〜&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Hello, WDOM&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;rimo_id&lt;/code&gt;は内部で使っている属性です。
無視して下さい。
テストなどで邪魔な場合は、&lt;code&gt;html_noid&lt;/code&gt;を使うと&lt;code&gt;rimo_id&lt;/code&gt;を除いたhtmlが取得できます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyElement&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# -&amp;gt; &amp;lt;div&amp;gt;&amp;lt;input&amp;gt;&amp;lt;h1&amp;gt;Hello, WDOM&amp;lt;/h1&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;親要素に自動的に追加&lt;/h3&gt;
&lt;p&gt;毎回appendChildを呼び出すのも面倒なので、インスタンス生成時に&lt;code&gt;parent&lt;/code&gt;引数で親要素を指定できるようにしてあります。&lt;/p&gt;
&lt;p&gt;先ほどの例は以下のように書き換えることができます。
（要素の追加される順番が先ほどと違ってしまいますが）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# h1要素を新しく作成して自分の子要素にする&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;textContent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello, WDOM&amp;#39;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# input要素を新しく作成して自分の子要素にする&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut5.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;子要素を自動的に追加&lt;/h3&gt;
&lt;p&gt;逆に、子要素をインスタンス作成時に追加することもできます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# 子要素として&amp;#39;Hello, WDOM&amp;#39;を持つh1要素を新しく作成し、子要素に追加&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello, WDOM&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# input要素を新しく作成して自分の子要素にする&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addEventListener&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;input&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut6.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;H1('Hello, WDOM', parent=self)&lt;/code&gt;としている部分では、第一引数が新しく作られる要素の子要素に追加されます。
文字列は自動的に&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Text"&gt;Textノード&lt;/a&gt;（&lt;code&gt;wdom.node.Text&lt;/code&gt;）に変換されます。
&lt;code&gt;H1(H2(), P(), ...)&lt;/code&gt;として複数の要素を追加することも可能です。&lt;/p&gt;
&lt;h3&gt;属性値を設定&lt;/h3&gt;
&lt;p&gt;インスタンス化する時に属性値を設定することもできます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;checkbox&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;input type=&amp;quot;checkbox&amp;quot;&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# JavaScript同様、以下のようにして設定することも可能です&lt;/span&gt;
&lt;span class="nb"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;checkbox&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# または input.type = &amp;#39;checkbox&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut7.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;属性はpythonの予約語とかぶっているので、&lt;code&gt;class_&lt;/code&gt;と末尾にアンダースコアをつけてください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;h1 class=&amp;quot;title&amp;quot;&amp;gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;# 以下と同じです&lt;/span&gt;
&lt;span class="n"&gt;h1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;h1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;class&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;title&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# または h1.classList.add(&amp;#39;title&amp;#39;)&lt;/span&gt;
&lt;span class="c1"&gt;# classList は複数追加可能です&lt;/span&gt;
&lt;span class="c1"&gt;# h1.classList.add(&amp;#39;title&amp;#39;, &amp;#39;heading&amp;#39;, ...)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut8.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;デフォルトのクラス属性を設定&lt;/h3&gt;
&lt;p&gt;よく使うタグとクラス属性の値をまとめて定義しておくことも可能です。&lt;/p&gt;
&lt;p&gt;例えばbootstrapのボタンはクラスに&lt;code&gt;class="btn"&lt;/code&gt;と指定する必要がありますが、これをデフォルトで定義されている(pythonの)クラスを作ることができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Button&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;class_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# 省略&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;button class=&amp;quot;btn&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut9.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クラス変数の&lt;code&gt;class_&lt;/code&gt;に指定したクラスが自動的に設定されます。
これは以下のように定義した場合とほぼ同じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;class&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;違いは、インスタンスから削除できないという点と、クラス変数として定義したclass属性はsubclassに継承されるという点です。&lt;/p&gt;
&lt;p&gt;前者は以下のような操作ができないことを意味します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;btn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;btn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;classList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# classListから&amp;#39;btn&amp;#39;クラスを削除しようとしても&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;btn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;button class=&amp;quot;btn&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;  # 削除されない&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;後者の継承されるという点は文字通りですが、継承されたクラスで&lt;code&gt;class_&lt;/code&gt;と指定しても置き換えられず、追加されます。
例えば&lt;code&gt;DefaultButton&lt;/code&gt;というクラスを作り、&lt;code&gt;class="btn btn-default"&lt;/code&gt;というクラス属性を持たせたい場合は、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;DefaultButton&lt;/span&gt;(&lt;span class="n"&gt;MyButton&lt;/span&gt;):
    &lt;span class="n"&gt;class_&lt;/span&gt; = &lt;span class="s"&gt;&amp;#39;btn-default&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;とするだけでクラス属性を追加することができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultButton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html_noid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;lt;button class=&amp;quot;btn btn-default&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;class定義のショートカット&lt;/h3&gt;
&lt;p&gt;クラス属性が違うだけの(Pythonの)クラスを&lt;code&gt;class&lt;/code&gt;文でいくつも定義するのは面倒なので、簡単に定義するための&lt;code&gt;wdom.tag.NewTagClass&lt;/code&gt;という関数を用意しました。&lt;/p&gt;
&lt;p&gt;この関数を使うことで、先ほどの&lt;code&gt;MyButton&lt;/code&gt;や&lt;code&gt;DefaultButton&lt;/code&gt;は次のように定義することができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NewTagClass&lt;/span&gt;

&lt;span class="n"&gt;MyButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NewTagClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;MyButton&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;DefaultButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NewTagClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;DefaultButton&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;btn-default&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut10.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NewTagClass&lt;/code&gt;の第一引数は新しく作るクラスの名前、第二引数はタグ、第三引数は継承するクラス、第四引数以降の名前付き引数はクラス変数になります。
第三引数はタプルで複数のクラスを指定することも可能です。&lt;/p&gt;
&lt;p&gt;これらの機能はDOM仕様ではなく独自仕様ですが、JavaScriptとPythonの違い、利便性等を考慮して実装しました。
独自仕様なので今後変更される可能性もあります。
ご注意ください。
（クラス変数の&lt;code&gt;class_&lt;/code&gt;は&lt;code&gt;classes&lt;/code&gt;にしてリストでクラスを指定する形にしたい気持ちもあります）&lt;/p&gt;
&lt;h2&gt;HTMLでの記述&lt;/h2&gt;
&lt;p&gt;構造を上記のような&lt;code&gt;appendChild&lt;/code&gt;などだけで作っていくのは大変なので、HTMLで記述してパースできるようにしてあります。
JavaScriptと同様、&lt;code&gt;innerHTML&lt;/code&gt;でHTML文字列を設定するだけです。&lt;/p&gt;
&lt;p&gt;例えば大きなリストを作る時は以下のようにすることができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Ul&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Ul&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerHTML&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;lt;li&amp;gt;...&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;lt;li&amp;gt;...&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;lt;li&amp;gt;...&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;lt;li&amp;gt;...&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut11.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;innerHTML&lt;/code&gt;は既存の子要素を全て削除して置き換えるのでご注意ください。&lt;/p&gt;
&lt;p&gt;各子要素にはリスト風オブジェクトの&lt;code&gt;ul.childNodes&lt;/code&gt;経由でアクセス可能です。
&lt;code&gt;ul.firstChild&lt;/code&gt;や&lt;code&gt;ul.lastChild&lt;/code&gt;などで最初・最後の子要素にもアクセスできます。
これもJavaScript（というかDOMの仕様）と同じです。
（上の例だと改行だけのTextノードも作られてしまうのですが、一応Chromeでの動作と同じです。）&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;insertAdjacentHTML(position, html)&lt;/code&gt;メソッドでもHTMLをパースできます。
このメソッドは既存の子要素は削除せず、&lt;code&gt;position&lt;/code&gt;で指定した位置に要素を挿入します。
詳細は&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/Element/insertAdjacentHTML"&gt;element.insertAdjacentHTML MDN&lt;/a&gt;などをご参照ください。&lt;/p&gt;
&lt;p&gt;なお&lt;code&gt;outerHTML&lt;/code&gt;は未実装です・・・&lt;/p&gt;
&lt;h2&gt;スタイルシートの適用&lt;/h2&gt;
&lt;p&gt;デフォルトの表示は寂しいので、スタイルシートを適用しましょう。
見栄えは重要です。&lt;/p&gt;
&lt;h3&gt;Web上のリソース読み込み&lt;/h3&gt;
&lt;p&gt;例としてBootstrapを使ってみます。&lt;/p&gt;
&lt;p&gt;Bootstrapの場合はcssとjavascript二つ（bootstrapとjquery）が必要なので、それぞれ&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;要素と&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;要素に追加します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Link&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Script&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Button&lt;/span&gt;

&lt;span class="n"&gt;document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c1"&gt;# &amp;lt;head&amp;gt;内にbootstrap.min.cssを読み込むlinkタグを追加&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Link&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;stylesheet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# &amp;lt;body&amp;gt;にjqueryとbootstrap.min.js追加&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Script&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Script&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# ボタン追加&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut12.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSSとJSは頻繁に使われると思うので、以下のショートカットも用意してあります。
（メソッド名は今後変更される可能性があります）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_cssfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_jsfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_jsfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut13.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;ローカルのファイル読み込み&lt;/h3&gt;
&lt;p&gt;独自に作ったcssファイルなどを読み込むことも可能です。&lt;/p&gt;
&lt;p&gt;例えば以下のようなディレクトリ構成で、&lt;code&gt;app.py&lt;/code&gt;から&lt;code&gt;static/css/app.css&lt;/code&gt;を読み込む場合を考えます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── static
│   └── css
│       └── app.css
├── app.py
├── module1.py
├── ...
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;app.py&lt;/code&gt;で次のように指定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;

&lt;span class="n"&gt;static_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;static&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_document&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_cssfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/static/css/app.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_app&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_static_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;static&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;static_dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut14.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app.add_static_path()&lt;/code&gt;の第一引数は、静的ファイルへアクセスする時のprefixになります。
指定したディレクトリ以下のファイルに&lt;code&gt;http://localhost:8888/{prefix}/{ファイル名}&lt;/code&gt;でアクセスできるようになります。
上記の例では&lt;code&gt;http://localhost:8888/static/css/app.css&lt;/code&gt;とアクセスするとapp.cssが表示されるはずです。&lt;/p&gt;
&lt;p&gt;prefixとディレクトリ名は異なっていても大丈夫です。
例えば&lt;code&gt;add_static_path('my_static', static_dir)&lt;/code&gt;とすることもでき、この場合は&lt;code&gt;document.add_cssfile('/my_static/css/app.css')&lt;/code&gt;とすることで&lt;code&gt;app.css&lt;/code&gt;を読み込むことができます。
ブラウザで&lt;code&gt;http://localhost:8888/my_static/css/app.css&lt;/code&gt;にアクセスすると、実際のcssファイルが表示されることが確認できるはずです。&lt;/p&gt;
&lt;p&gt;cssやjsファイルに限らず、画像やhtmlなどの静的ファイルでも何でも利用可能です。&lt;/p&gt;
&lt;p&gt;なお、prefixはurlに使える値なら何でも構いませんが、&lt;code&gt;_static&lt;/code&gt;というprefixだけはライブラリ側で使っているので他の名前を使ってください。&lt;/p&gt;
&lt;h2&gt;DOMの便利な新機能&lt;/h2&gt;
&lt;p&gt;まだブラウザに実装されていない機能もいくつか実装しているので紹介します。&lt;/p&gt;
&lt;h3&gt;ParentNode/ChildNode インターフェイスの各メソッド&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;appendChild&lt;/code&gt;は単一の要素しか追加できませんが、&lt;code&gt;append&lt;/code&gt;というメソッドでは複数の要素をまとめて追加できます。
さらに、文字列も自動的にTextノードに変換されます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Ul&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Li&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Ul&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;li1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Li&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;li2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Li&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appendChild&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;# appendを使うと&lt;/span&gt;
&lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;li2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# と一度で終わる&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut15.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同様に、先頭にまとめて追加する&lt;code&gt;prepend&lt;/code&gt;や、前後に追加する&lt;code&gt;after&lt;/code&gt;や&lt;code&gt;before&lt;/code&gt;も利用可能です。&lt;/p&gt;
&lt;p&gt;内部的には、&lt;code&gt;appendChild&lt;/code&gt;などは毎回通信を行ってブラウザ上の表示を更新しているのに対し、&lt;code&gt;append&lt;/code&gt;などでは一度に表示を更新しているので、パフォーマンス的にも有利です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/ParentNode"&gt;ParentNode MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/NonDocumentTypeChildNode"&gt;NonDocumentTypeChildNode MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/ja/docs/Web/API/ChildNode"&gt;ChildNode MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dom.spec.whatwg.org/#interface-parentnode"&gt;ParentNode DOM Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dom.spec.whatwg.org/#nondocumenttypechildnode"&gt;NonDocumentTypeChildNode DOM Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dom.spec.whatwg.org/#interface-childnode"&gt;ChildNode DOM Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Custom Element&lt;/h3&gt;
&lt;p&gt;独自タグも限定的・実験的ですがサポートしています。
ブラウザ上では特に何もせず、&lt;code&gt;innerHTML&lt;/code&gt;などでhtmlをパースした時に作られるPythonのクラスを指定できるだけですが。。。&lt;/p&gt;
&lt;p&gt;WebComponentsの仕様自体が流動的なので、今後変更される可能性はあります。&lt;/p&gt;
&lt;h4&gt;独自タグの定義&lt;/h4&gt;
&lt;p&gt;先ほど作った&lt;code&gt;MyElement&lt;/code&gt;クラスは&lt;code&gt;div&lt;/code&gt;タグとして表示されていましたが、独自の&lt;code&gt;&amp;lt;my-element&amp;gt;&lt;/code&gt;タグとして定義してみます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Div&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# 独自タグを&amp;#39;my-element&amp;#39;と指定&lt;/span&gt;
    &lt;span class="n"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my-element&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;# 省略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut16.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;違いはクラス変数として&lt;code&gt;tag = 'my-element'&lt;/code&gt;と設定していることだけです。
先ほどと同様に&lt;code&gt;Div&lt;/code&gt;クラスを継承していますが、特に意味はありません。
&lt;code&gt;Span&lt;/code&gt;などでも大丈夫です。&lt;/p&gt;
&lt;p&gt;これをCustom Tagとして登録します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;defaultView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;customElements&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my-element&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MyElement&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以前のCustom Elementの仕様では&lt;code&gt;docuemnt.registerElement&lt;/code&gt;というメソッドが使われていましたが、&lt;a href="http://w3c.github.io/webcomponents/spec/custom/"&gt;最新の仕様&lt;/a&gt;では&lt;code&gt;window.customElements.define&lt;/code&gt;というメソッドを使うようになっていたので、wdomもそちらに合わせました。
&lt;code&gt;document.defaultView&lt;/code&gt;はブラウザ上での&lt;code&gt;window&lt;/code&gt;オブジェクトに相当します。
（現状のWDOMではほとんど空のオブジェクトになっていますが・・・）&lt;/p&gt;
&lt;p&gt;これで&lt;code&gt;my-element&lt;/code&gt;という独自タグが登録できたので、以下のように使うことができます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# body要素の末尾に &amp;lt;my-element&amp;gt;&amp;lt;/my-element&amp;gt; を挿入&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertAdjacentHTML&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;beforeend&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;my-element&amp;gt;&amp;lt;/my-element&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# または、createElementで新規作成&lt;/span&gt;
&lt;span class="n"&gt;my_element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my-element&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;既存タグの拡張&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;is&lt;/code&gt;属性を使った既存タグの拡張にも対応しています。
前述したbootstrapのbutton要素の&lt;code&gt;MyButton&lt;/code&gt;や&lt;code&gt;DefaultButton&lt;/code&gt;を定義してみます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wdom.tag&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Div&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# tag = &amp;#39;button&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;class_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;is_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;my-button&amp;#39;&lt;/span&gt;  &lt;span class="c1"&gt;# tag ではなく is_ に名前を指定&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DefaultButton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;class_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;btn-default&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;is_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;default-button&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;defaultView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;customElements&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;my-button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;extends&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;defaultView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;customElements&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;default-button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;extends&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;button&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innerHTML&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;button is=&amp;quot;my-button&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&amp;lt;button is=&amp;quot;default-button&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstChild&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MyButton&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lastChild&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;DefaultButton&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://github.com/miyakogi/wdom_tutorial_ja/blob/master/tut17.py"&gt;サンプルコード&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Pythonの)クラス定義時にクラス変数の&lt;code&gt;is_&lt;/code&gt;（最後にアンダースコア）で名前を指定します。
tagは拡張したいタグ（今回は継承元の&lt;code&gt;Button&lt;/code&gt;クラスで定義されているので指定不要）です。&lt;/p&gt;
&lt;p&gt;定義したクラスを登録する時に、&lt;code&gt;define&lt;/code&gt;の第一引数に名前（&lt;code&gt;is_&lt;/code&gt;の値）を指定し、第三引数に辞書で&lt;code&gt;{'extends': 'button'}&lt;/code&gt;と拡張したい元のタグ名を指定します。&lt;/p&gt;
&lt;p&gt;このように登録することで、&lt;code&gt;&amp;lt;button is="my-button"&amp;gt;&lt;/code&gt;などのhtmlから&lt;code&gt;MyButton&lt;/code&gt;クラスのインスタンスが作られるようになります。&lt;/p&gt;
&lt;p&gt;（タグとisの指定がわかりにくく、いかにも混乱しそうですが、今の所こういう仕様なのでそれに合わせています）&lt;/p&gt;
&lt;h4&gt;Custom Elementを使う上での注意&lt;/h4&gt;
&lt;p&gt;できるだけ早い段階で独自タグを定義するようにしてください。
定義前にインスタンスを作ってしまうと、異なるクラスのインスタンスが作られてしまいます。
一応&lt;code&gt;customElements.define&lt;/code&gt;で登録された時に無理やりクラスは置き換えていますが、&lt;code&gt;__init__&lt;/code&gt;は呼ばれません。
特に、&lt;code&gt;is&lt;/code&gt;を使った既存タグの拡張は、インスタンスを作った後に&lt;code&gt;setAttribute('is', '...')&lt;/code&gt;などとしても（現時点では）クラスは変更されないので注意してください。&lt;/p&gt;
&lt;p&gt;今後&lt;a href="http://www.html5rocks.com/ja/tutorials/webcomponents/customelements/#lifecycle"&gt;ライフサイクルコールバックメソッド&lt;/a&gt;に相当する機能は作りたいと考えていますが、事前に登録を済ませておいたほうが安全なのは変わらないと思います。&lt;/p&gt;
&lt;h2&gt;おわりに&lt;/h2&gt;
&lt;p&gt;長くなってしまいましたが、お読みいただきありがとうございました。&lt;/p&gt;
&lt;p&gt;説明が必要な独自機能を中心に書いたので、あまりDOMで規定されている機能については触れませんでしたが、基本的な機能は実装されています。
DOM関係の実装状況は&lt;a href="https://github.com/miyakogi/wdom/wiki/Features"&gt;こちら&lt;/a&gt;をご参照ください。
他にも開発に便利な機能が少しあったりするのですが、それは別記事で紹介したいと思います。&lt;/p&gt;
&lt;p&gt;当面はCustom Elementの実装と正式なドキュメントの整備をすすめていきたいと考えています。
あと、個別のHTML要素のクラスも&lt;code&gt;HTML〇〇Element&lt;/code&gt;の形で（主要なものは）実装したいですね。
イベント関係も、ドラッグ＆ドロップとかはまだ実装できていないので実装しないと・・・&lt;/p&gt;
&lt;p&gt;もちろんバグが見つかればできるだけ早く修正します。
もう少し落ち着いたらPyPIに登録します。&lt;/p&gt;</summary><category term="python"></category><category term="wdom"></category></entry><entry><title>Vimのパッケージをインストール・アップデートしてヘルプ作るスクリプトを書きました</title><link href="https://miyakogi.github.io/blog/20160308/vimpack_py.html" rel="alternate"></link><updated>2016-03-08T23:20:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-03-08:blog/20160308/vimpack_py.html</id><summary type="html">&lt;p&gt;先日からVim本体のパッケージ機能を使い、プラグインマネージャは使わない生活をしています。
とはいえプラグインのアップデートやヘルプの生成は手作業では面倒なので、そのあたりを処理してくれるPythonのスクリプトを書きました。&lt;/p&gt;
&lt;p&gt;始めは&lt;a href="https://github.com/miyakogi/dotfiles"&gt;dotfileをgit管理&lt;/a&gt;（今まではhgで管理してbitbucketに置いてました）にしてプラグインをsubmoduleにすれば十分かと思ったのですが、やってみたら意外と面倒でした。
Pythonで書いたのは、自分の場合VimがあるところならまずPythonもあるというのと、3.4で入った&lt;a href="http://docs.python.jp/3/library/pathlib.html"&gt;pathlib&lt;/a&gt;というパスをいい感じに扱えるライブラリを使ってみたかったからです。&lt;/p&gt;
&lt;p&gt;この記事を書きながらログ周りやオプションを整備してリファクタリングもしましたが、あくまで自分用に書いたスクリプトなので機能は最低限です。
gitにしか対応していませんが、パッケージ機能を試したい方はもし良ければお使いください。
なお、Vimのパッケージ機能についてはヘルプや&lt;a href="http://h-miyako.hatenablog.com/entry/2016/02/29/211534"&gt;先日の記事&lt;/a&gt;をご参照ください。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h4&gt;修正&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;デフォルトで読み込むパスが&lt;code&gt;ever&lt;/code&gt;から&lt;code&gt;start&lt;/code&gt;に変更されたので修正&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;機能&lt;/h2&gt;
&lt;p&gt;インストール、アップデート、チェックの3つの機能があります。
インストールするプラグインをJSON形式で記述して &lt;code&gt;~/.vim/pack/{好きな名前}/pack.json&lt;/code&gt; に置いておくと勝手に読み込みます。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;インストールは不要です。
標準ライブラリ以外の依存もありません。
ファイル（&lt;a href="https://github.com/miyakogi/dotfiles/blob/master/vimpack.py"&gt;最新版&lt;/a&gt;または&lt;a href="https://github.com/miyakogi/dotfiles/blob/36fc432b5bee58b40f871ceb19c7e903fa483cd8/vimpack.py"&gt;今日のバージョン&lt;/a&gt;）を適当なところに保存して実行するだけです。
実行権限をつけてパスの通った所に置いておけば手軽に実行できます。&lt;/p&gt;
&lt;p&gt;実行にはPython3.5以上が必要です。
もしかしたら3.4でも動くかもしれませんが未確認です。&lt;/p&gt;
&lt;p&gt;なお、この記事の内容は今日のバージョンベースです。
Vimの仕様変更や私の気分次第で最新版は記事の内容と異なる場合がありますのでご注意下さい。&lt;/p&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;実行は &lt;code&gt;python3 vimpack.py {コマンド} [設定ファイル名（デフォルトpack.json）]&lt;/code&gt; です。
コマンドは必須で、設定ファイルの名前はオプションです。&lt;/p&gt;
&lt;p&gt;インストールしたいリポジトリの情報を記入した &lt;code&gt;pack.json&lt;/code&gt; というファイルを &lt;code&gt;~/.vim/pack/{好きな名前}&lt;/code&gt; のディレクトリに置いておきます。
この設定ファイルに書かれたリポジトリがそのディレクトリの下の&lt;code&gt;start&lt;/code&gt;または&lt;code&gt;opt&lt;/code&gt;ディレクトリにcloneされます。
以下のように複数のディレクトリに設定ファイルを置くこともできます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/.vim/pack
├── 好きな名前1
│   ├── pack.json
│   ├── opt
│   └── start
├── 好きな名前2
│   ├── pack.json
│   ├── opt
│   └── start
└── 好きな名前3
    ├── pack.json
    ├── opt
    └── start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;※注: Vim 7.4.1527以前のバージョンでは&lt;code&gt;start&lt;/code&gt;ではなく&lt;code&gt;ever&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;設定ファイルのフォーマット&lt;/h3&gt;
&lt;p&gt;現時点では次のようなフォーマットにしています。
Vimの仕様変更や私の気分次第で変わるかもしれません。
もし動かなかったら&lt;a href="https://github.com/miyakogi/dotfiles/blob/master/pack.json"&gt;私の設定ファイル&lt;/a&gt;を確認してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;&amp;#39;start&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;&amp;#39;github.com&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;username1/plugin_repo&amp;#39;,&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;other_user/plugin_repo2&amp;#39;&lt;/span&gt;
        &lt;span class="err"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt;
    &lt;span class="err"&gt;&amp;#39;opt&amp;#39;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;&amp;#39;github.com&amp;#39;:&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;another_user/plugin&amp;#39;,&lt;/span&gt;
            &lt;span class="err"&gt;&amp;#39;another_user/somplugin&amp;#39;&lt;/span&gt;
        &lt;span class="err"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JSONなので末尾コンマ禁止です。エラーになります。
苦情はPython標準ライブラリの&lt;a href="http://docs.python.jp/3/library/json.html"&gt;json&lt;/a&gt;モジュールにお願いします。&lt;/p&gt;
&lt;p&gt;必ず読み込むプラグインは&lt;code&gt;start&lt;/code&gt;以下に、遅延読み込みしたいものは&lt;code&gt;opt&lt;/code&gt;以下に記述します。
それぞれのディレクトリに配下のリポジトリがクローンされます。
リポジトリの指定は&lt;code&gt;{ホスト名: [リポジトリ1, リポジトリ2, ...]}&lt;/code&gt;という形のホスト名をキーとしたリストになります。&lt;/p&gt;
&lt;p&gt;github以外からインストールする時はホスト名を追加して別に配列を持たせてください。
名前の衝突は一切考慮していないので、万一衝突した場合は先にcloneされたほうが勝ちます。
なお、一度Pythonの辞書オブジェクトに変換される都合上順番はランダムになります。&lt;/p&gt;
&lt;h3&gt;インストール&lt;/h3&gt;
&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;勝手に設定ファイルを探してきて、丁寧に一つずつcloneします。
すでにディレクトリがある場合はcloneせずにスキップします。
並列実行をしないのは面倒そうだった（特にログ出力）からです。
全部まとめてインストールとかそう何度もしないと思うので、のんびりコーヒーでも飲みながら眺めていてください。&lt;/p&gt;
&lt;p&gt;ちなみに、ログはカラー対応のターミナルだと色がつきます。
ここはがんばりました。
対応していない端末だと色がつかないだけでなく制御文字がそのまま表示されて残念な感じになります。
これを機に色の出る端末に乗り換えましょう。&lt;/p&gt;
&lt;p&gt;インストールされたプラグインに&lt;code&gt;plugin&lt;/code&gt;ディレクトリがなかった場合は作って&lt;code&gt;_.vim&lt;/code&gt;というダミーのファイルを作成します。
気になる方はグローバルな&lt;code&gt;.gitignore&lt;/code&gt;に追加しておいてください。
ついでに&lt;code&gt;doc&lt;/code&gt;ディレクトリの中身を&lt;code&gt;~/.vim/doc&lt;/code&gt;以下にリンクし、ヘルプ用のタグファイルを作成します。
これらの処理は&lt;code&gt;--no-dummy&lt;/code&gt;や&lt;code&gt;--no-doc&lt;/code&gt;オプションをつけることでスキップできます。&lt;/p&gt;
&lt;h3&gt;アップデート&lt;/h3&gt;
&lt;p&gt;以下のコマンドを実行します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py update
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これを実行すると、&lt;code&gt;pack.json&lt;/code&gt;に記述されたリポジトリだけでなく、JSONのキーとして存在しているディレクトリ（&lt;code&gt;start&lt;/code&gt;と&lt;code&gt;opt&lt;/code&gt;）のgitリポジトリを全てアップデート（&lt;code&gt;git pull&lt;/code&gt;）します。
&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;も実行しているので多分submoduleも更新できると思います。
なお、設定ファイルに書かれていてもインストールされていないリポジトリは無視します。&lt;/p&gt;
&lt;p&gt;インストールの場合と同様、ダミーファイルの作成とヘルプの更新も行います。
同じくオプションでスキップ可能です。&lt;/p&gt;
&lt;h3&gt;チェック&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 vimpack.py check
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;設定ファイルにないリポジトリや未インストールのリポジトリを確認して、もしあれば警告を出します。
ついでにダミーファイルの作成とヘルプの更新を行います。
git以外でプラグインを追加した時に便利かな、と思ってつくってみました。&lt;/p&gt;
&lt;h3&gt;オプション&lt;/h3&gt;
&lt;h4&gt;--help&lt;/h4&gt;
&lt;p&gt;ヘルプを表示します。
Pythonの&lt;a href="http://docs.python.jp/3/library/argparse.html"&gt;argparse&lt;/a&gt;が作ってくれるやつです。
オプションの確認ができます。&lt;/p&gt;
&lt;h4&gt;設定ファイル名&lt;/h4&gt;
&lt;p&gt;デフォルトは&lt;code&gt;pack.json&lt;/code&gt;です。
他の名前にしたい場合は &lt;code&gt;python vimpack.py check config.json&lt;/code&gt; などのように他のオプションの前に指定してください。
フルパスを指定するとそのファイルだけを読み込みます。&lt;/p&gt;
&lt;h4&gt;--no-dummy&lt;/h4&gt;
&lt;p&gt;ダミーファイルの作成をスキップします。&lt;/p&gt;
&lt;h4&gt;--no-doc&lt;/h4&gt;
&lt;p&gt;ヘルプファイルへのシンボリックリンク作成をスキップします。&lt;/p&gt;
&lt;h4&gt;--loglevel&lt;/h4&gt;
&lt;p&gt;出力するログのレベルを設定できます。
レベルは &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; などがあります。
大文字小文字は関係ありません。&lt;/p&gt;
&lt;p&gt;デフォルトは &lt;code&gt;info&lt;/code&gt; です。
&lt;code&gt;debug&lt;/code&gt;が最も詳細（たくさん）なログを表示します。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;初めてpathlibをガッツリ使ってみました。
少しクセがありますが、基本的に便利でいい感じでした。&lt;/p&gt;
&lt;p&gt;もしvimpack.pyのバグに気づいたら、コメントでもリポジトリのissueでもいいので教えていただけるとすごく嬉しいです。
機能追加は・・・しないと思いますので適当にいじってください。&lt;/p&gt;</summary><category term="vim"></category><category term="python"></category></entry><entry><title>Vimのパッケージ機能を試してみました</title><link href="https://miyakogi.github.io/blog/20160229/vim_pack.html" rel="alternate"></link><updated>2016-02-29T17:52:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-29:blog/20160229/vim_pack.html</id><summary type="html">&lt;p&gt;最近&lt;a href="https://github.com/Shougo/dein.vim"&gt;dein.vim&lt;/a&gt;がバズったりVim本体にパッケージ機能が追加されたり、Vim界隈は第二次プラグインマネージャ戦争の気配に包まれています &lt;em&gt;[要出典]&lt;/em&gt;。
dein.vimはすでにいくつか紹介記事がありますが、本体の方はあまり情報を見かけかなかったので先日試した結果を含めて紹介します。&lt;/p&gt;
&lt;p&gt;この機能は入ったばかりなので、今後仕様の変更があるかもしれませんし、バグもあるかもしれませんし、（たぶん）機能追加もあると思います。
記事の内容が古くなっているかもしれないので、日付とVimのバージョンをよく確認してください。&lt;/p&gt;
&lt;p&gt;試す人は本体のデバッグに自分のVimを捧げる気持ちでいきましょう。
バックアップ重要です。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;[2016/03/07: &lt;code&gt;:loadplugin&lt;/code&gt;が削除され&lt;code&gt;:packadd&lt;/code&gt;が追加されたので修正]&lt;/p&gt;
&lt;h2&gt;メリット&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;プラグインマネージャが裏で色々頑張ってくれていることが理解できる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;必要なもの&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最新のVim&lt;/li&gt;
&lt;li&gt;インストールするプラグイン&lt;/li&gt;
&lt;li&gt;たくさんエラーが出てもいいVim環境&lt;/li&gt;
&lt;li&gt;エラーやバグに負けない強い心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は Kubuntu 15.10 で試しました。
Vimのバージョンは7.4.1225くらいでした。&lt;/p&gt;
&lt;h3&gt;情報源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help packages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help :packadd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help 'packpath'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困ったら&lt;a href="https://github.com/vim/vim"&gt;ソースコード&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;とりあえずプラグインを入れてみる&lt;/h2&gt;
&lt;p&gt;プラグインを入れるディレクトリは大別して二種類です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/ever&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/opt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的には&lt;code&gt;ever&lt;/code&gt;以下に自動的に読み込んでほしいプラグインを置いて、&lt;code&gt;opt&lt;/code&gt;以下に必要な時に読み込む（遅延読込する）プラグインを置く形です。
すでにNeoBundleなどのプラグインマネージャを使っている場合はプラグインが一つのディレクトリにまとまっていると思いますので、その中身をまるっと&lt;code&gt;ever&lt;/code&gt;以下にコピーして&lt;code&gt;neobundle#begin()&lt;/code&gt;〜&lt;code&gt;neobundle#end()&lt;/code&gt;あたりを&lt;code&gt;if 0&lt;/code&gt;と&lt;code&gt;endif&lt;/code&gt;で囲めばすぐ試せます（微妙な仕様の違いがあるので、そのままだと大量のエラーを経験することになりますが）。&lt;/p&gt;
&lt;p&gt;例えばplugin1とplugin2を&lt;code&gt;ever&lt;/code&gt;以下に置く場合は次のようなディレクトリ構成になります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/.vim
├── pack
│   ├── mypack
│   │   ├── ever
│   │   │   ├── plugin1
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── README.md
│   │   │   ├── plugin2
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── readme.md
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;この状態でVimを起動すると、&lt;strong&gt;.vimrcなどを読み込んだ後に&lt;/strong&gt;自動的にplugin1とplugin2がruntimepathに追加されます。&lt;/p&gt;
&lt;p&gt;太字部分重要です。
つまりvimrcの中ではプラグインが定義するコマンドや関数は使えません。
例えば&lt;code&gt;NoeBundle ~&lt;/code&gt;とかやっていた部分は全滅します。
autoload関数も使えないので、設定で&lt;code&gt;call plugin#setup(...)&lt;/code&gt;などとしている部分も全滅です。
また、プラグインもロードされていないので、例えば&lt;code&gt;if neobundle#is_installed('プラグイン名')&lt;/code&gt;などのかわりに単純に&lt;code&gt;if get(g:, 'loaded_プラグイン名')&lt;/code&gt;などと置き換える事もできません。
値の設定（&lt;code&gt;let g:superplugin_default_option = 1&lt;/code&gt;など）は大丈夫です。&lt;/p&gt;
&lt;p&gt;私はこれを回避するために、プラグインを使っている部分を別ファイルに分離してオートコマンドで&lt;code&gt;VimEnter&lt;/code&gt;時に読み込むようにしました。
&lt;code&gt;~/.vim/after/plugin&lt;/code&gt;以下も試してみましたが、ここもパッケージのロードより先に読み込まれていました。
最終的にはプラグインを使う設定を&lt;code&gt;~/.vim/config/plugins.vim&lt;/code&gt;に書いて、次のような設定をvimrcに追加しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; filereadable&lt;span class="p"&gt;(&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/.vim/config/plugins.vim&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  autocmd myvimrc &lt;span class="nb"&gt;VimEnter&lt;/span&gt; * source &lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="sr"&gt;/.vim/&lt;/span&gt;config/plugins.&lt;span class="k"&gt;vim&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これで&lt;code&gt;plugins.vim&lt;/code&gt;の中ではプラグインが使えます。
インストールの確認も&lt;code&gt;if get(g:, 'loaded_~')&lt;/code&gt;や&lt;code&gt;if exists(':PluginCommand')&lt;/code&gt;などでできます。
&lt;code&gt;g:loaded_~&lt;/code&gt;を設定しないプラグインは、とりあえず&lt;code&gt;if match(&amp;amp;runtimepath, 'プラグイン名')&lt;/code&gt;で確認しています。&lt;/p&gt;
&lt;p&gt;注意する点は、オプション値の設定（&lt;code&gt;let g:~~~ = ...&lt;/code&gt;と設定するタイプ）はvimrc内に書いたほうが安全ということです。
読み込み時に設定値のチェックをしてそのまま使っているプラグインが結構あるようで、それらがロードされる前に値の設定を済ませる必要があるからです。&lt;/p&gt;
&lt;h3&gt;読み込まれないプラグイン対策&lt;/h3&gt;
&lt;p&gt;現在は&lt;code&gt;plugin&lt;/code&gt;ディレクトリがないプラグインは読み込まれない（runtimepathに追加されない）ようです。
これはautoload関数だけを提供しているプラグイン（&lt;a href="https://github.com/kana/vim-textobj-user"&gt;textobj-user&lt;/a&gt;など）やカラースキーム（&lt;a href="https://github.com/altercation/vim-colors-solarized"&gt;solalized&lt;/a&gt;など）、スニペット集（&lt;a href="https://github.com/Shougo/neosnippet-snippets"&gt;neosnippet-snippets&lt;/a&gt;）などが該当し、読み込まれません。
これが仕様として確定するのかわかりませんが、私はとりあえずの回避策として&lt;code&gt;mkdir plugin &amp;amp;&amp;amp; touch plugin/_.vim&lt;/code&gt;と適当にファイルを作って置きました。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;plugin&lt;/code&gt;直下に&lt;code&gt;*.vim&lt;/code&gt;ファイルがなく、さらにディレクトリがあるようなプラグインも読み込まれませんでした。
仕様なのか微妙ですが、runtimepathには追加されているのでバグのような気がします。
ありがたいことに&lt;a href="https://github.com/vim-jp/issues/issues/848"&gt;動作確認とIssue報告&lt;/a&gt;までしていただいたので、7.5のリリースまでに修正されるのではないかと。。。
これも上記と同様に適当なファイル（&lt;code&gt;*.vim&lt;/code&gt;）をpluginディレクトリに置くことで読み込み可能です。&lt;/p&gt;
&lt;h2&gt;遅延読み込み&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;opt&lt;/code&gt;以下のプラグインはそのままでは読み込まれません。
&lt;code&gt;:packadd {プラグインのディレクトリ名}&lt;/code&gt;を実行して初めて有効になります。&lt;/p&gt;
&lt;p&gt;私はとりあえずインサートモードで使うプラグインを&lt;code&gt;opt&lt;/code&gt;に置き、以下のような設定を行いました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt; abort
  loadplugin delimitMate
  loadplugin &lt;span class="k"&gt;vim&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;smartchr
  loadplugin ...
  ...
&lt;span class="c"&gt;  &amp;quot; マッピングなどの設定があればする&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; s:init_delimitMate&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;  &amp;quot; 二回目以降実行されないようにautocmdを削除&lt;/span&gt;
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; lazy_load_i
&lt;span class="k"&gt;endfunction&lt;/span&gt;

augroup lazy_load_i
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="nb"&gt;InsertEnter&lt;/span&gt; * &lt;span class="k"&gt;call&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt;
augroup END
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NeoBundleはコマンド実行や関数呼び出しやマッピングをトリガにして遅延読み込みできますが、大変そうだったのでそこまでやっていません。
起動時間に露骨に影響するようなプラグインはそもそも入れてないというのもありますが。
（NERDTreeやsyntasticは読み込みに結構時間かかるので使っていません）&lt;/p&gt;
&lt;h2&gt;起動時間&lt;/h2&gt;
&lt;p&gt;みなさん気になると思います。
ざっくり雑に測っただけですが、とりあえず遅延読み込みしないで全部読み込むような条件ではdein.vimと同じか少し速いくらい、NeoBundleより30~40%速い感じでした。
ただ、上に書いたように読み込まれないプラグインがけっこうあって、気づいたものは対策しましたがまだ読み込まれていないものもありそうなので、実際にはdein.vimと同じくらいじゃないかと思います。&lt;/p&gt;
&lt;p&gt;余談ですが、Vimの起動時間が気になる人は（もしやっていないなら）ファイルタイプの設定を自前で用意してデフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;を読まないようにするといいと思います。
デフォルトの設定だと人生で一度も使わないであろうファイルタイプの設定が大量にあるので。
デフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;は&lt;code&gt;share/vim/vim74/filetype.vim&lt;/code&gt;にあります。
ここから必要そうな設定を拝借してvimrcで設定するなりして、&lt;code&gt;let g:did_load_filetypes=1&lt;/code&gt;しておけばデフォルトのファイルタイプ設定は読まれなくなります。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;NeoBundleがメンテナンスモードに入ると聞いてdein.vimへの移行を考えている方、どうせプラグイン周りの設定をいじるならついでに本体のパッケージ機能も試してみませんか？
いっしょに人柱してバグを探しましょう。&lt;/p&gt;</summary><category term="vim"></category></entry><entry><title>Python製の静的サイトジェネレータを色々試してみました</title><link href="https://miyakogi.github.io/blog/20160215/static_site_generators.html" rel="alternate"></link><updated>2016-02-15T15:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-15:blog/20160215/static_site_generators.html</id><summary type="html">&lt;p&gt;このブログははてなブログで運用していますが、最近ブログを静的サイトジェネレータで作ってGitHub Pagesにおこうかな、と考えています。
ということでいくつか静的サイトジェネレータを調べたのでまとめました。&lt;/p&gt;
&lt;p&gt;ついでに比較用に作ったブログをいくつかGitHub Pagesで公開しておきます。
内容はこのブログの過去数回分です。
同じテーマでも日本語だと雰囲気が違ったりするので、よかったら参考にしてください。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;ブログの移行を考えたきっかけは、はてなブログでgifファイルのアップロードができなかったからです。
それ以外は特に不満はないのですが、せっかくなので勉強がてら静的サイトジェネレータを使ってみようかと。&lt;/p&gt;
&lt;p&gt;私が静的サイトジェネレータに求める機能としては、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdownで書ける&lt;ul&gt;
&lt;li&gt;バッククォート３つでのコードブロックも対応&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一からデザインするのは無理なのでそれなりのテーマがある&lt;/li&gt;
&lt;li&gt;開発が続いている&lt;/li&gt;
&lt;li&gt;画像も扱える&lt;ul&gt;
&lt;li&gt;静的コンテンツへのリンクを開発環境と本番で変えられる&lt;/li&gt;
&lt;li&gt;例えば、開発時は http://localhost:8000/、本番は https://user.github.io/page/ とか&lt;ul&gt;
&lt;li&gt;本番環境でもドメインのルートに置けるなら気にならないと思います。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;トップに表示する記事の要約の範囲指定&lt;ul&gt;
&lt;li&gt;はてなブログの「続きを読む」的なやつ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;です。
あと、いざという時にコードを読んで対応できるように、自分の読めるPython製に絞って検討しました。
なのでJekyllやHugo、Hexoは検討していません。&lt;/p&gt;
&lt;p&gt;逆に重視しない機能は、運用（公開）の自動化や確認用のサーバーです。
GitHub Pagesで公開する場合はghp-importを使って&lt;code&gt;ghp-import [directory]&lt;/code&gt;して&lt;code&gt;git push origin gh-pages&lt;/code&gt;するだけなので、特になくてもいいかと。
サーバーも、ビルドするコマンドさえ提供されていれば&lt;a href="https://pypi.python.org/pypi/livereload"&gt;liveralod&lt;/a&gt;を使ったスクリプトを用意するので不要でした。&lt;/p&gt;
&lt;p&gt;今回検討した静的サイトジェネレータは以下の五つです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.getpelican.com/"&gt;Pelican&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/koenbok/Cactus"&gt;Cactus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.getlektor.com/"&gt;Lektor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.getnikola.com/"&gt;Nikola&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog_nikola/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mulholland.xyz/docs/ark/"&gt;Ark&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog_ark/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にドキュメンテーションツールのSphinxやMkDocsでもhtmlを出力できますが、これらはブログ向けではないので候補から外しました。
Hydeも気になりましたが、サイトのデザインが好みでなかったのと面倒になったのでパスしました。&lt;/p&gt;
&lt;p&gt;以下、メモです。
結論としてはとりあえずPelicanを使ってみることにしたので、その前提でお願いします。
長いです。&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://docs.getpelican.com/"&gt;Pelican&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog/"&gt;日本語ブログのサンプル&lt;/a&gt; (&lt;a href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;をベースにフォントと文字サイズいじりました)&lt;/p&gt;
&lt;p&gt;Python製静的サイトジェネレータの中では最も有名で、GitHubのスターも一番多いです。
日本語でもPelicanでブログを作った記事はたくさんありました。&lt;/p&gt;
&lt;p&gt;テーマやプラグインが豊富でドキュメントも充実しているので、だいたいのことはなんとかなりそうです。
テーマは&lt;a href="http://www.pelicanthemes.com/"&gt;Pelican themes&lt;/a&gt;にスクリーンショット付きでたくさん紹介されています。&lt;/p&gt;
&lt;p&gt;使い方はすでにたくさん公開されているので割愛します。
基本的には&lt;code&gt;pelican-quickstart&lt;/code&gt; -&amp;gt; &lt;code&gt;content&lt;/code&gt;以下に記事追加 -&amp;gt; &lt;code&gt;make html&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;画像は&lt;code&gt;content/images&lt;/code&gt;ディレクトリに入れておけば出力先にコピーされます。
リンクする時は&lt;code&gt;{filename}/images/filename.png&lt;/code&gt;で、 &lt;code&gt;{filename}&lt;/code&gt;の部分はビルド時に設定した&lt;code&gt;SITE_URL&lt;/code&gt;で置き換えられます。
開発用と本番用の設定ファイルが分離されているので、開発用（pelicanconf.py）では&lt;code&gt;SITE_URL=''&lt;/code&gt;にしておいて、本番用（publishconf.py）で&lt;code&gt;SITE_URL='https://user.github.com/page/'&lt;/code&gt;のようにしておけば、開発（&lt;code&gt;make html&lt;/code&gt;）と本番（&lt;code&gt;make publish&lt;/code&gt;）でURLを切り替えられます。&lt;/p&gt;
&lt;p&gt;記事の要約はWord数で指定できるのですが、日本語だとwordカウントが微妙だったので自分で簡単なプラグインを書きました。&lt;/p&gt;
&lt;p&gt;テンプレートはJinja2なので、カスタマイズの敷居も低そうでした。
また、プラグイン用のフックが色々用意されているので、欲しい機能があったら自分で追加するのも簡単そうでした。&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/koenbok/Cactus"&gt;Cactus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Djangoベースの静的サイトジェネレータです。
スター数は2600くらいでかなり多い方です。
デザイナー向けを謳っていて、記事の公開など運用面でかなりサポートしてくれる感じですが、今回そういう機能は不要です。&lt;/p&gt;
&lt;p&gt;インストールは普通に&lt;code&gt;pip install cactus&lt;/code&gt;でインストールされます。
使い方は、サイトの新規作成が&lt;code&gt;cactus create path&lt;/code&gt;で、ビルドは&lt;code&gt;cactus build&lt;/code&gt;、閲覧用サーバーの起動は&lt;code&gt;cactus serve&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;ドキュメントは見つかりませんでした。
GitHubのREADMEにかなり書かれているので、それで十分ということなのでしょうか？
チュートリアルのビデオはありましたが、README以上の情報はありませんでした。&lt;/p&gt;
&lt;p&gt;Django使うとなんか大げさな気がしてそれだけで少し敬遠してしまいました・・・
あと &lt;code&gt;cactus serve&lt;/code&gt; でサーバーを立ち上げたらいきなりエラーになって印象悪かったです・・・
設定ファイルがjsonなのも個人的には微妙でした。&lt;/p&gt;
&lt;p&gt;デフォルトではブログというよりもポートフォリオサイトのようなものが作られます。
ブログも作れるということでブログの例が&lt;a href="https://github.com/koenbok/CactusBlog/"&gt;公開されている&lt;/a&gt;のですが、これ記事も全部html（djangoテンプレート）で書かれています・・・
Markdown使いたかったら自分でビルドスクリプト書けということでしょうか・・・
一応プラグインサポートもあるのかな？
誰も考えていないわけではなさそうです（&lt;a href="https://github.com/koenbok/Cactus/pull/96"&gt;First pass at Markdown-only blog posts&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;ということで、デザインはいい感じだったのですが手軽にブログが書ける感じではなかったので見送ります。&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.getlektor.com/"&gt;Lektor&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;昨年末に公開された新しい静的サイトジェネレータです。
作者はFlaskやJinja2、clickなど有名なpythonパッケージを作っているArminさんです。
Flaskを作った方ということで、拡張性・柔軟性も強く意識しているようです。
ドキュメントも充実しています。
ただ、まだptyhon3で動かないみたいですね・・・これは厳しい・・・
Issueは立っていたので、すぐサポートされると思います。&lt;/p&gt;
&lt;p&gt;これは普通の静的サイトジェネレータとは毛色が異なります。
記事を書いたり画像などのリソースを追加したり、コンテンツの管理は基本的に管理画面または&lt;a href="https://www.getlektor.com/downloads/"&gt;専用のアプリ&lt;/a&gt;から行うようです。
ローカルでhtmlファイルを出力するという意味では静的サイトジェネレータなのですが、運用面ではWordPressなどのCMSに近い感じです。&lt;/p&gt;
&lt;p&gt;コマンドラインから操作する場合は、まず&lt;code&gt;lektor quickstart&lt;/code&gt;でプロジェクトを作って、そこで&lt;code&gt;lektor server&lt;/code&gt;するとサーバーが立ち上がります。
&lt;code&gt;http://localhost:5000&lt;/code&gt;にアクセスすると&lt;s&gt;寂しい感じの&lt;/s&gt;ページが表示されると思います。
&lt;code&gt;http://localhost:5000/admin&lt;/code&gt;にアクセスすると管理画面が開いて、そこから記事の追加などが行えます。&lt;/p&gt;
&lt;p&gt;記事本文はMarkdownで書けます。
管理画面からプレビューもできます。
記事のデータはテキストで保存されるのですが、&lt;code&gt;.lr&lt;/code&gt;という専用？のフォーマットです。
直接テキストを編集するような使い方はあまり想定されていないのかもしれません。&lt;/p&gt;
&lt;p&gt;公開されたばかりなので、テーマが少ないのは仕方ないと思います。
テンプレートエンジンは当然Jinja2なので、自分で作るのも難しくはないと思います。&lt;/p&gt;
&lt;p&gt;私はVimで記事を書きたかったので見送りました。
WordPressのような感じで管理画面から記事を投稿したい人や、複数人で共同してサイトを作成する場合などはいいかもしれません。
まだできたばかりなので、興味ある人は今から使ってテーマやプラグインを作ると第一人者になれますよ！&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.getnikola.com/"&gt;Nikola&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog_nikola/"&gt;日本語ブログのサンプル&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;普通の静的サイトジェネレータです。
python-announce-listに頻繁に更新メールが送られてくるので、開発は活発だと思います。&lt;/p&gt;
&lt;p&gt;Pelicanよりもマイナーなのでテーマや情報は少ないです。
&lt;a href="https://getnikola.com/handbook.html"&gt;ドキュメント&lt;/a&gt;は非常に充実しているので、使う上で困ることはそんなになさそうです。
機能は豊富だと思います。&lt;/p&gt;
&lt;p&gt;デフォルト（デモ？）のサイトを作るのは&lt;code&gt;nikola init --demo [path]&lt;/code&gt;です。
後は&lt;code&gt;nikola build&lt;/code&gt;とか&lt;code&gt;nikola serve&lt;/code&gt;でビルドしたり閲覧用のサーバーを起動したりできます。
デフォルトのフォーマットはrstですが、設定ファイル(conf.py)に以下の行を追加することでmarkdownも使えます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;POSTS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.md&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;# ここを追加&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.rst&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;nikola new_post&lt;/code&gt;で新しい記事が作れるのはいいですね。
どの静的サイトジェネレータもタイトルや日付などのメタデータを入力する必要があったのですが、フォーマットを覚えてられないので他の記事からコピペして使うのが地味に面倒でした。
（Pelicanはプラグインとかありそうですが、見つからなかったのでスクリプトを書きました。）&lt;/p&gt;
&lt;p&gt;画像などの静的ファイルは&lt;code&gt;files&lt;/code&gt;ディレクトリに放り込めば出力先にコピーされます。
困ったのはコンテンツへのリンクでした。
設定ファイルの&lt;code&gt;SITE_URL&lt;/code&gt;でサイトのURLを指定するとそこを起点としたリンクが作成されるのですが、これを開発環境と本番環境で切り替える方法がわかりませんでした。
組み込みのサーバ(&lt;code&gt;nikola serve&lt;/code&gt;)を立ち上げてローカルで確認する場合はローカルのリンクに変換されているようなので、これを使えばそんなに不便はないと思います。
私は組み込みのサーバーを使わずにlivereloadでファイルの変更を検出して自動でビルド・ブラウザのリロードまでしたかったのですが、ちょっとその方法はわかりませんでした。&lt;/p&gt;
&lt;p&gt;記事の要約は、区切りとなるコメントを挿入することで範囲を指定できます。
Markdownの場合、デフォルトでは&lt;code&gt;&amp;lt;!-- TEASER_END --&amp;gt;&lt;/code&gt;というコメントまでが要約になります。
はてなブログと同じ&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;を使いたかったので、設定ファイルで以下のように設定しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;INDEX_TEASERS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;TEASER_REGEXP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r&amp;#39;&amp;lt;!--\s*(more)(:(.+))?\s*--&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今回見送った理由は、上記の理由の他に、ビルドにかかる時間が他より長く感じたからです。
長いと言っても数秒で終わるのですが、なんとなく不安を感じて。
あと、なんかプロジェクトのロゴが残念な感じだったので。&lt;/p&gt;
&lt;p&gt;サンプルを見ていただければわかりますが、デフォルトのbootstrapを使ったデザイン結構いい感じです。
珍しいものでサイトを作りたい人にはいいかもしれません。&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://mulholland.xyz/docs/ark/"&gt;Ark&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog_ark/"&gt;日本語ブログのサンプル&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;めっちゃマイナーです（githubのスター20個くらい）。
つい最近pypiに登録されたばかりです。&lt;/p&gt;
&lt;p&gt;実は静的サイトジェネレータでブログを作ろうかと思ったきっかけの一つはこれです。
デフォルトのテーマがかっこいいんですよ。
WordPressのtwentyfifteenがベースらしいのですが、WordPressはこんなにかっこいいテーマがすぐ使えるんですね、人気なの納得しました。&lt;/p&gt;
&lt;p&gt;機能はシンプルです。
新しいので情報はないに等しいと思うのですが、&lt;a href="http://mulholland.xyz/docs/ark/guide.html"&gt;ドキュメント&lt;/a&gt;が充実しているので意外と普通に使えました。
むしろドキュメントが充実していて機能もシンプルなので、CactusやLektorよりとっつきやすかったです。&lt;/p&gt;
&lt;p&gt;使い方は簡単で、&lt;code&gt;pip install ark&lt;/code&gt; でインストールして &lt;code&gt;ark init&lt;/code&gt; すると必要なファイルが用意されます。
あとは &lt;code&gt;ark build&lt;/code&gt; すれば out ディレクトリに出力されます。
とはいえ、いざとなったらソースを読む覚悟は必要です。
今回、サイトのタイトルを設定する方法がわからなかったのでソース眺めましたが、設定ファイルに&lt;code&gt;title='タイトル'&lt;/code&gt;で設定出来ました。
このあたりはテーマ（テンプレート）次第な気もしますが。&lt;/p&gt;
&lt;p&gt;ブログ記事は &lt;code&gt;src/[posts]&lt;/code&gt; ディレクトリに置くだけです。
新規記事の作成や既存記事の編集はコマンドも用意されていて、&lt;code&gt;ark edit posts filename&lt;/code&gt;で作成・編集できます。
各記事はMarkdownで書けて、ファイルの最初にメタデータとしてタイトル、日付を書き、後は本文を書くだけです。
メタデータには著者やタグなども書けます。
コマンドから作成した時は時刻が入力されています。&lt;/p&gt;
&lt;p&gt;Markdownの拡張はconfig.pyに以下の設定を追加する必要がありました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;extensions&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fenced_code&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;codehilite&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;extra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;画像などは&lt;code&gt;src&lt;/code&gt;以下のディレクトリに置けば出力時にコピーされます。
ディレクトリも追加可能なので、&lt;code&gt;src/images&lt;/code&gt;などのディレクトリを作っておけば同じ構造で出力されます。
リンクは&lt;code&gt;@root/&lt;/code&gt;で始めれば設定ファイル（config.py）で指定するサイトのルートURLに置き換えられます。
ルートURLを開発用と本番用で切り替えるコマンドなどはないようですが、ルートURLを空（&lt;code&gt;root=""&lt;/code&gt;）にしておくと上記の&lt;code&gt;@root/&lt;/code&gt;の部分を相対リンクに変換してくれるので、特に問題なく使えました。&lt;/p&gt;
&lt;p&gt;正直かなり惹かれました。
作者の方は（これ用なのかわかりませんが）Markdownの方言？的なもの（&lt;a href="https://github.com/dmulholland/syntex"&gt;Syntex&lt;/a&gt;）やDjango/Jinja風のテンプレートエンジン（&lt;a href="https://github.com/dmulholland/ibis"&gt;Ibis&lt;/a&gt;）も作って公開しています。
このジェネレータはそれらの形式もサポートしていますが、今回は興味なかったので内容は確認しませんでした。
デフォルトでMarkdownやJinja2もサポートしているので実用上問題ありません。&lt;/p&gt;
&lt;p&gt;採用しなかった理由は、さすがにマイナー過ぎて今後が心配なことと、記事の要約を出力する機能がみつからなかったことです。
プラグインの機構はあるので拡張で作れそうですが、要約出力から作る必要がありそうで、ちょっとめんどくさそうでした。
よく見たら記事のアーカイブもない？
設定で出せるんでしょうか。
タグ一覧は設定があったので出せると思います（未確認）。&lt;/p&gt;
&lt;p&gt;ブログ用に使うのはまだちょっと厳しい感じでした。
小さなプロジェクトのページくらいなら使えそうな気がします。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;結局Pelicanを使ってみることにしました。
テーマが豊富なのは大きいです。
せっかくなのでマイナーなものとか新しいものに挑戦したかったのですが、結局無難なところに落ち着いてしまって悲しい・・・
Arkは何かのプロジェクトページで使うかもしれません。&lt;/p&gt;
&lt;h3&gt;あとがき&lt;/h3&gt;
&lt;p&gt;この記事書いてたらmattnさんがJekyll 3.0の記事を公開していました。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mattn.kaoriya.net/software/20160215110235.htm"&gt;Big Sky :: GitHub Pages が Jekyll 3.0 になり、ますますブログが書きやすくなった。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jekyllも便利そうです。&lt;/p&gt;</summary><category term="python"></category><category term="pelican"></category><category term="static site generator"></category></entry><entry><title>Livemark.vimを色々更新しました</title><link href="https://miyakogi.github.io/blog/20160214/livemark_update.html" rel="alternate"></link><updated>2016-02-14T13:14:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-14:blog/20160214/livemark_update.html</id><summary type="html">&lt;p&gt;Markdown文書をリアルタイムで更新するVimプラグイン、&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;Livemark.vim&lt;/a&gt;を更新しました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+channel&lt;/code&gt;なVimじゃなくても&lt;code&gt;+python&lt;/code&gt;なら動作するので、よければお試し下さい。
安定したものがいい場合は&lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt;などをおすすめします。&lt;/p&gt;
&lt;p&gt;オプションはGitHubの&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;README&lt;/a&gt;に一応全て書いてあります。
まだバグがあるかもしれませんが、その時は&lt;a href="https://github.com/miyakogi/livemark.vim/issues"&gt;Issue&lt;/a&gt;に報告していただけると喜んで対応します。Issueを書くのが面倒でしたら、Twitterで&lt;a href="https://twitter.com/MiyakoDev"&gt;@MiyakoDev&lt;/a&gt;にメンションしていただいても大丈夫です。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h3&gt;変更点&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://h-miyako.hatenablog.com/entry/2016/02/06/135203"&gt;先日の記事&lt;/a&gt;以降に追加した機能（オプション）は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユーザー指定のcss/jsを読み込む設定追加&lt;/li&gt;
&lt;li&gt;シンタックスハイライトのテーマ指定追加&lt;/li&gt;
&lt;li&gt;プレビュー画面のスクロール同期を止めるオプション追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ついでに、Pythonで書かれたプレビュー用のサーバー部分を&lt;a href="https://github.com/miyakogi/livemark"&gt;別リポジトリ&lt;/a&gt;に分離しました。
まだ分離しただけに近い状態ですが、機能を整理してドキュメントやテストを追加して、Vim以外のエディタからも使えるような形にできたらいいなぁ、と思っています。&lt;/p&gt;
&lt;h4&gt;CSS/JSファイルの読み込み&lt;/h4&gt;
&lt;p&gt;デフォルトでは日本語向けBootstrapテーマの&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt;を読み込んでいます。
それに伴い、CDNからjQueryもロードしています。&lt;/p&gt;
&lt;p&gt;ちょっと使うには十分だと思いますが、自分のブログのテーマと同じデザインで使いたいなどの希望があるだろうと考え、CSSやJSを指定できるようにしました。
パスの処理が雑なので、Windowsだと動かないかもしれません。&lt;/p&gt;
&lt;p&gt;指定方法は、例えばCSSを追加してデフォルトのCSSを使わない場合は以下のようになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_css_files &lt;span class="p"&gt;=&lt;/span&gt; [expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/dotfiles/static/css/bootstrap.ja.min.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_no_default_css &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;複数のCSSファイルを指定したい場合はそれぞれリストに追加してください。
リストに追加された順番で読み込みます。
URLを指定すれば（たぶん）Web上のリソースを読み込むこともできます。
その場合はURLを指定してください。
例えば、&lt;code&gt;let g:livemark_css_files = ['https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js']&lt;/code&gt;のような感じです。&lt;/p&gt;
&lt;p&gt;デフォルトのCSSを使用し、CSSを追加したいだけの場合は二行目は不要です。
その場合、ブラウザ上での読み込み順は デフォルトのCSS -&amp;gt; 追加されたCSSの順になります。&lt;/p&gt;
&lt;p&gt;JSについても同様です。各オプションの&lt;code&gt;css&lt;/code&gt;を&lt;code&gt;js&lt;/code&gt;に変更してください。&lt;/p&gt;
&lt;h4&gt;シンタックスハイライトのテーマ設定&lt;/h4&gt;
&lt;p&gt;シンタックスハイライトには&lt;a href="http://pygments.org/"&gt;pygments&lt;/a&gt;を使っています。
デフォルトでは特に指定していないのでpygmentsのデフォルトテーマが使われますが、他にも色々なテーマがあるので変更できるようにしました。&lt;/p&gt;
&lt;p&gt;変更するには以下の設定をvimrcに追加してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_highlight_theme &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;テーマ名&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用可能なテーマはインストールされているpygmentsに依存します。
コマンドラインで確認するには、以下のコマンドを実行して下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -c &lt;span class="s2"&gt;&amp;quot;import pygments.styles; print(pygments.styles.STYLE_MAP.keys())&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示されたキーが利用可能なテーマ名です。
Livemarkのオプションで特定のpythonを指定している場合はpython3の部分をそちらに変えてください。&lt;/p&gt;
&lt;h4&gt;スクロールの同期を止めるオプションの追加&lt;/h4&gt;
&lt;p&gt;デフォルトではVimのカーソル位置に応じて画面をスクロールしています。
具体的には、Vimのバッファに表示されている最初の行が画面の最上部に来るように調整しています。&lt;/p&gt;
&lt;p&gt;とはいえ、MarkdownからHTMLに変更する時に行番号がずれてしまうので、一応頑張って調整していますが完璧ではありません。
また、書いている時に動かない方がいい場合もあるかと思います。&lt;/p&gt;
&lt;p&gt;ということで、以下のオプションでスクロールを停止できます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_disable_scroll &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内部的な話&lt;/h3&gt;
&lt;p&gt;内部的にはかなり大きな変更を行いました。&lt;/p&gt;
&lt;p&gt;当初はカーソル移動やテキストの編集が行われるたびに全文をhtmlにパースし、プレビュー画面全部を書き換えるという力技で実装されていたのですが、さすがにこれだと大きなファイルの時に描画の遅れが深刻だったので修正しました。
今は差分を検出して変更のあった部分だけを更新しています。
個人的にはJSツラいのでJSではなくPythonで処理しました。&lt;/p&gt;
&lt;p&gt;ちょうど今&lt;a href="https://github.com/miyakogi/wdom_py"&gt;wdom&lt;/a&gt;というPythonからブラウザ上のDOMを操作するライブラリを開発しているので、これを使ってHTMLからDOMにパースして変更箇所だけをブラウザ上で変更、という処理にしています。Livemark用のJSはスクロール用の関数を数行書いただけで、他はPythonで実装できました。変更がない時はHTMLへの変換も行わないので、カーソル移動はかなりスムーズになったと思います。&lt;/p&gt;
&lt;p&gt;なお、このライブラリ（wdom）は絶賛開発途中です。
Livemarkにバグがあっても「まぁ、そういう時もあるよね」という温かい心で接してください。&lt;/p&gt;
&lt;p&gt;ちなみに、wdomで目指すところはほぼJSフリーでelectron/ブラウザを使ったGUIアプリの開発です。
昨年からelectronが流行ってますけど、JSでデスクトップアプリ作りたい人だけじゃなくて、CSSフレームワーク（Bootstrapとか）のために渋々JS書いてる人も多いんじゃないの？というのが開発の動機です。
&lt;s&gt;つまり既存のGUIライブラリは見た目が残念・・・&lt;/s&gt;
今はLivemarkで色々使ってみて、必要な機能の確認とバグを洗い出している感じです。
なのでまだドキュメントもありませんし、APIも変わる可能性があります。
落ち着いたらPyPIに登録して &lt;strong&gt;「まだじゃわすくりぷとで消耗しているの？」&lt;/strong&gt; 的な煽りタイトルの記事を書きたいと思っています。
ヘタれたらもっと穏便なタイトルにするので優しくしてください。&lt;/p&gt;
&lt;p&gt;以上です。
開発中のものを色々取り入れているのでバグがある可能性大ですが、人柱精神旺盛な方、よろしければお試しください。&lt;/p&gt;</summary><category term="vim"></category><category term="python"></category></entry><entry><title>カバレッジ取得サービスの比較（Coveralls.ioとCodecove.io)</title><link href="https://miyakogi.github.io/blog/20160206/ci1.html" rel="alternate"></link><updated>2016-02-06T17:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-06:blog/20160206/ci1.html</id><summary type="html">&lt;p&gt;※ 注意：この記事には主観とグチが含まれています。&lt;/p&gt;
&lt;p&gt;コードのカバレッジ取得サービスを調べてみました。&lt;a href="https://coveralls.io/"&gt;Coveralls.io&lt;/a&gt;と&lt;a href="https://codecov.io/"&gt;Codecov.io&lt;/a&gt;の比較です。&lt;/p&gt;
&lt;p&gt;↓こんな感じのバッジがREADMEに表示されるやつです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://codecov.io/github/miyakogi/coveralls_sample?branch=master"&gt;&lt;img alt="codecov.io" src="https://codecov.io/github/miyakogi/coveralls_sample/coverage.svg?branch=master" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;TravisCIなどで自動テストを行い、ついでにテストのカバレッジも取得している方は多いと思います。
カバレッジを取得できるCIサービスだと coveralls を使っているプロジェクトが多いようですが、自分が試した時はなんか反応が鈍かったりgithubのリポジトリの更新が上手く反映されなかったり...とあまりいい印象がなかったので、他のサービスも試して比べてみました。他というか&lt;a href="https://codecov.io/"&gt;Codecov&lt;/a&gt;しか試してませんが。Codecovは&lt;a href="http://blog-ja.sideci.com/entry/2016/01/13/110000"&gt;SideCIさんのブログ記事&lt;/a&gt;で知りました。ありがとうございます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;結論：&lt;a href="https://codecov.io/"&gt;Codecov&lt;/a&gt;いい感じ！おすすめですよ！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;利用方法&lt;/h2&gt;
&lt;p&gt;どちらも公開リポジトリは無料です。プライベートリポジトリは有料プランになります。&lt;/p&gt;
&lt;p&gt;公開リポジトリの使い方はどちらも大差ありません。Githubのアカウント連携で認証して、連携したいリポジトリを指定して、Travisとも連携してテスト後にそれぞれのサービス向けに用意されているコマンドを叩くだけです。Travis + Pythonの場合、&lt;code&gt;.travis.yml&lt;/code&gt;に以下のように設定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;pip install pytest pytest-cov&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;pip install coveralls codecov&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;script&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;py.test --cov [module or package]&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;after_success&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;coveralls&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;codecov&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;インストールの二行目で両方のサービス用のパッケージをインストールして、after_successのところでそれぞれのサービス用のコマンドを実行して結果を送信しています。&lt;/p&gt;
&lt;p&gt;実際には使う方のサービスだけ設定すればOKです。ってゆーかですね、coverallsはこれだけで済むということに気づくまで結構時間がかかりました。&lt;/p&gt;
&lt;h4&gt;以下、しばらくcoverallsへの愚痴です&lt;/h4&gt;
&lt;p&gt;下の画像はcoverallsのドキュメントのpythonの説明です。本当にこれだけです。やる気が感じられません。好みじゃないのでリンクは貼りません。対応言語は結構たくさんありました。Rubyとかはドキュメントも結構充実してました。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls python document" src="https://miyakogi.github.io/blog/images/coveralls_pydoc.png" /&gt;&lt;/p&gt;
&lt;p&gt;まずpypiにcoveralls用のパッケージが二つあります。coverallsとpython-coverallsです。よくわからないのでざっくり説明を見た結果、おそらく大差ありません。coverallsの方がユーザーが一桁くらい多そうでした。公式が一つだけ用意してそれだけドキュメントに書いておいてくれればいいのに・・・&lt;/p&gt;
&lt;p&gt;また、coverallsの説明にはテストを走らせたあとに&lt;code&gt;coverage run&lt;/code&gt;を実行してカバレッジを計算すると説明があるのですが、&lt;code&gt;py.test&lt;/code&gt;を使った場合の説明がありません。私はpytestでテストを走らせてpytest-covというパッケージでテストと同時にカバレッジを取得していたので、追加でさらにcoverageを走らせるのか、スキップするテストの設定はどうするのか、カバレッジの計算から除外するモジュールの設定はどうするのか、などの情報がなくて困りました。実際にはpytest-covがcoverageを走らせているっぽいので特に何もしなくてよかったのですが。これは自分の知識不足が悪いのですが。。。情報少ない。。。そもそもトライするためのリポジトリをgithubに作っても、タイミングが悪かったのかgithubの更新が上手く取得できず、かなりストレスを感じました。&lt;/p&gt;
&lt;h4&gt;一方、codecovは&lt;/h4&gt;
&lt;p&gt;他の言語の説明でも結果のレポートはpipでインストールしたcodecovを使っていたので、pythonメインでやっている企業という印象です。&lt;a href="https://github.com/codecov/example-python"&gt;公式のリポジトリ&lt;/a&gt;には必要十分な説明がって、すぐに使えました。&lt;code&gt;coverage&lt;/code&gt;を使う方法、&lt;code&gt;nosetest&lt;/code&gt;を使う方法、&lt;code&gt;pytest&lt;/code&gt;を使う方法全て書かれています。また、Travisとの連携やCircleCIとの連携も書かれています。&lt;/p&gt;
&lt;h2&gt;両サービスの比較&lt;/h2&gt;
&lt;p&gt;比較用のリポジトリをGithubに用意しました。それぞれのバッジから対象サービスを開けます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/miyakogi/coveralls_sample"&gt;miyakogi/coveralls_sample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;バッジのデザインは大差ありません。カバレッジが表示されて、カバレッジが低いと赤っぽい色になります。&lt;/p&gt;
&lt;h3&gt;リポジトリのページ&lt;/h3&gt;
&lt;p&gt;バッジから対象リポジトリの結果を開いたところです。（上：coveralls、下：codecov）
どちらも全体のカバレッジはすぐわかるように大きく表示されています。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls repository top" src="https://miyakogi.github.io/blog/images/coveralls_top.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov repository top" src="https://miyakogi.github.io/blog/images/codecov_top.png" /&gt;&lt;/p&gt;
&lt;p&gt;Coverallsはビルド毎のカバレッジ変化が表示されているのですが、個別のファイルのカバレッジはパッと見ではわかりません。ここからさらにリンクをクリックしてページ遷移する必要があります。&lt;/p&gt;
&lt;p&gt;Codecovは最新のカバレッジしか表示されていませんが、個別のファイルのカバレッジも最初から表示されており、問題のあるファイルがすぐにわかります。この表示はツリー形式とリスト形式で切り替え可能です。また、ビルド毎のカバレッジの変化をグラフ表示する機能もあります（後述）。&lt;/p&gt;
&lt;h3&gt;テスト漏れ箇所の表示&lt;/h3&gt;
&lt;p&gt;どちらのサービスも行ベースでテストされている/されていない箇所を表示する機能があります。
むしろこの機能のためにカバレッジ取得サービスを使うようなものなので、ないと話になりません。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls file view" src="https://miyakogi.github.io/blog/images/coveralls_file.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov file view" src="https://miyakogi.github.io/blog/images/codecov_file.png" /&gt;&lt;/p&gt;
&lt;p&gt;テストされている行は緑、されていない行は赤くなっています。
色に関しては好みの範囲だと思いますが、私はcodecovの方が違いがわかりやすくて好きです。&lt;/p&gt;
&lt;p&gt;ちなみに、個別のファイルの結果を表示させるまでのクリック数は、Githubのリポジトリから&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coveralls&lt;ul&gt;
&lt;li&gt;バッジ→ ビルド番号か何かクリック→ ファイル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;codecov&lt;ul&gt;
&lt;li&gt;バッジ→ ファイル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となっていてcodecovの方がファイルへのアクセスはしやすくなっています。その上、ユーザーが少ないからなのか、codecovの方がページを開くのが速くて快適です(体感)。&lt;/p&gt;
&lt;p&gt;また、codecovは&lt;a href="https://github.com/codecov/browser-extension#codecov-extension"&gt;Chrome, Firefox, Opera向けのブラウザ拡張機能&lt;/a&gt;が用意されています。この拡張をインストールすると、Githubでcodecovと連携しているリポジトリのファイルを開いた時にテストの状況が表示されるようになります。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov github extension" src="https://miyakogi.github.io/blog/images/codecov_github.png" /&gt;&lt;/p&gt;
&lt;p&gt;邪魔な時は「Coverage xx.xx%」のところをクリックすれば消せます。
Github上でカバレッジが確認できるのはポイント高いと思います。
見た目もいい感じです。&lt;/p&gt;
&lt;h3&gt;その他の機能&lt;/h3&gt;
&lt;p&gt;Codecovはslackなどへの通知機能もあるようです。Coverallsもあるのかもしれませんがよくわかりません。&lt;/p&gt;
&lt;p&gt;Codecovはリポジトリのページにビルド毎のカバレッジ変化が表示されていませんでしたが、カバレッジの変化をグラフ表示する機能があります。前述のサンプルリポジトリのグラフはこれです。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov.io" src="https://codecov.io/github/miyakogi/coveralls_sample/branch.svg?branch=master" /&gt;&lt;/p&gt;
&lt;p&gt;バッジのようにMarkdownやHTMLで簡単に貼り付けることができます。上のグラフのMarkdownはこんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;![codecov.io](https://codecov.io/github/miyakogi/coveralls_sample/branch.svg?branch=master)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;バッジやグラフのMarkdown表示などはここから取得できます。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov graph code" src="https://miyakogi.github.io/blog/images/codecov_getgraph.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;サイトのデザインは全体的にとてもオシャレな感じなのですが、なぜグラフだけこんなに残念な感じなのでしょうか。エクセルでももう少しマシなグラフを書いてくれそうです。しかも下部の会社名の所、見事にデザインが崩れています。改善を期待しています。。。&lt;/small&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;というわけで、全体的にcoverallsが印象悪かったせいでcodecovの広告記事みたいになってしまいましたが、codecov良かったのでしばらく使うつもりです。&lt;/p&gt;
&lt;p&gt;Codecovいい感じなのでよかったら検討に加えてみてください。私は本当にcodecovと関係ないのですが、この分野かなり生き残り厳しいので (TravisやCircleCI以外の消えていったCIサービスは数知れません)、サービス終了されて渋々coverallsへ移行するという状況は避けたいのです・・・よろしくお願いします・・・&lt;/p&gt;
&lt;p&gt;長文にお付き合いいただきありがとうございました。参考になれば幸いです。&lt;/p&gt;</summary><category term="Python"></category><category term="CI"></category></entry><entry><title>Vim の channel と json のパフォーマンス</title><link href="https://miyakogi.github.io/blog/20160206/channel1.html" rel="alternate"></link><updated>2016-02-06T10:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-06:blog/20160206/channel1.html</id><summary type="html">&lt;p&gt;先日公開した &lt;a href="https://github.com/miyakogi/livemark.vim"&gt;livemark.vim&lt;/a&gt; には想像以上にたくさんの反響をいただきました。
ありがとうございます。
最近では海外の方からもGithubのスターをいただきました。
思いつきで作ったプラグインでしたが、せっかくなので普段使いできるようにいくつか更新しました。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;ul&gt;
&lt;li&gt;channel をサポートしない vim では python を使うように修正&lt;ul&gt;
&lt;li&gt;channelをサポートするvimでもpythonを使いたい場合は &lt;code&gt;let g:livemark_force_pysocket=1&lt;/code&gt; で使えます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;マークダウンの変換及びプレビュー表示をするpythonを指定する設定追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_python='/path/to/python'&lt;/code&gt; で指定できます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビューを表示するブラウザを vim から設定できるように修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_browser='[ブラウザ名]'&lt;/code&gt; で設定できます&lt;/li&gt;
&lt;li&gt;設定可能なブラウザと名前は&lt;a href="http://docs.python.jp/3/library/webbrowser.html#webbrowser.register"&gt;ここ&lt;/a&gt;を参照してください&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビュー表示に使うポートと vim からデータを送るために使うポートの設定を追加&lt;ul&gt;
&lt;li&gt;それぞれ &lt;code&gt;g:livemark_browser_port&lt;/code&gt; と &lt;code&gt;g:livemark_vim_port&lt;/code&gt; です&lt;/li&gt;
&lt;li&gt;デフォルト値はそれぞれ 8089, 8090 です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とはいえ、まだ安定しているとは言いがたい状態なので、マークダウンのプレビューには &lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt; などを使うのがいいと思います。&lt;/p&gt;
&lt;p&gt;今の実装だと変更がある度に画面全体を再描画していて大きいファイルのプレビューは厳しいので、差分だけ更新するような処理を実装中です。&lt;/p&gt;
&lt;p&gt;そんな感じで地味に更新したりしてたのですが、&lt;a href="http://ftp.vim.org/vim/patches/7.4/7.4.1244"&gt;このパッチ&lt;/a&gt;でchannel関係の関数名が全部変わったので動かなくなりました（つらい&lt;/p&gt;
&lt;p&gt;&lt;img alt="channel error" src="https://miyakogi.github.io/blog/images/channel_error.png" /&gt;&lt;/p&gt;
&lt;p&gt;修正してもまた仕様変更あったら面倒だなぁ、と微妙にやる気が減退気味だったのと、pythonでデータ送ってもそんなにもたつきを感じなかったりして「もしかして Vim の channel より python の方が速い・・・？いや channel も json も C で書かれてるしそんなはずは・・・でも Vim だし何が起きるかわからん」という疑問が沸き起こったので測ってみました。&lt;/p&gt;
&lt;p&gt;Livemark.vim では編集中のバッファの文字列を取得して json として送っているので、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;データをjsonに変換する処理&lt;/li&gt;
&lt;li&gt;変換されたデータをサーバーに送りつける処理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;に分けて計測しました。また、Vimは一旦jsonに変換してから送る場合 (raw channel) とjsonへの変換も一気に行う場合 (json channel) の両方を測りました。&lt;/p&gt;
&lt;p&gt;データを送りつけられるサーバーがボトルネックになると意味ないので、サーバーは Nim で書きました。 サーバーのコードはこんな感じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;nativesockets&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;net&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bindAddr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;accepted&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;connection closed&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;

&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ベンチマークのコードはこんな感じ&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;scriptencoding&lt;/span&gt; utf&lt;span class="m"&gt;-8&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; s:data &lt;span class="p"&gt;=&lt;/span&gt; readfile&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;EOF
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;vim&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s:data&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_vim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsonencode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_raw&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;raw&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_sendraw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="c1"&gt;# data = json.dumps(vim.eval(&amp;#39;s:data&amp;#39;)).encode(&amp;#39;utf-8&amp;#39;)&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_connection&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
EOF
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;let&lt;/span&gt; handler &lt;span class="p"&gt;=&lt;/span&gt; ch_open&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; {&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;: &lt;span class="s1"&gt;&amp;#39;json&amp;#39;&lt;/span&gt;}&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_sendexpr&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;,&lt;/span&gt; s:data&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_close&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;py_eval:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_vim&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_vim:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_py:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_raw&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;raw_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;python:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;data.txt&lt;/code&gt; には &lt;code&gt;This is sample data\n\n&lt;/code&gt; が10万回、合計20万行入っています。
Pythonの場合は Vim で読み込んだデータを python に渡す処理も入ってくるので、そこは別で計測しています。&lt;/p&gt;
&lt;p&gt;結果はこうなりました。（単位は秒、Vim のバージョンは 7.4.1265 です）&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;vim (json)&lt;/th&gt;
&lt;th&gt;vim (raw)&lt;/th&gt;
&lt;th&gt;python&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vim -&amp;gt; py&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.165894&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;json化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.496177&lt;/td&gt;
&lt;td&gt;0.300104&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;データ送信&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.023818&lt;/td&gt;
&lt;td&gt;0.087396&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;合計&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.519995&lt;/td&gt;
&lt;td&gt;0.553394&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合計あまり変わらない・・・&lt;s&gt;Pythonよりは速くて「channelすごい！jsonすごい！」って記事になる予定だったのに・・・・&lt;/s&gt;jsonのエンコードにすごい時間かかってますね・・・よく考えたら、一度Vim scriptになってるのでむしろよく頑張ってる方だと思います。
「あれ、たしかpython標準のjsonモジュールって・・・」って&lt;a href="http://postd.cc/memory-use-and-speed-of-json-parsers/"&gt;などの疑問&lt;/a&gt;を持ってはいけません。&lt;/p&gt;
&lt;p&gt;というわけで！Pythonで処理してもあまりパフォーマンスに影響なさそうなので！むしろ20万行のマークダウンとか書かないと思うので！channelの仕様変更に負けずに地味に更新していきたいと思います！レッツポジティブ！&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>Vim に channel が実装されたので Markdown をプレビューするプラグインを作りました</title><link href="https://miyakogi.github.io/blog/20160129/livemark1.html" rel="alternate"></link><updated>2016-01-29T19:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-01-29:blog/20160129/livemark1.html</id><summary type="html">&lt;p&gt;Vimにchannel機能が実装されました。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mattn.kaoriya.net/software/vim/20160129114716.htm"&gt;Big Sky :: Vim にchannel(ソケット通信機能)が付いた。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨日から株価・為替は乱高下し、大臣の辞任、日銀のマイナス金利導入決定など国内では大きなニュースが続いていますが、Vimmerにとってはこのパッチが最も影響があったのではないでしょうか。&lt;/p&gt;
&lt;p&gt;というわけで、せっかくなのでchannel機能を使ってプラグインを書いてみました。
みんな大好きMarkdownのリアルタイムプレビューです。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;miyakogi/livemark.vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;channelを使ってみたかっただけなので、今のところデバッグ・エラー処理・設定などはやっつけです。
お遊び以外では使わないでください。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;インストール方法は普通のvimプラグインと同じです。コピーするなりプラグインマネージャを使うなり、お好みの方法でインストールしてください。&lt;/p&gt;
&lt;p&gt;NeoBundleをお使いの場合は &lt;code&gt;NeoBundle 'miyakogi/livemark.vim'&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;残念ながらVimはまだmarkdownの変換やwebサーバーなどの機能はないので、その辺りはPythonで処理しています。 以下のようにpythonのライブラリを別途インストールして下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install misaka pygments tornado
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pygments はコードのシンタックスハイライトに使っています。&lt;/p&gt;
&lt;p&gt;Vimのpythonではなく外部プロセスでpythonを起動しているので、vimは&lt;code&gt;+python3&lt;/code&gt;でなくても動きます。&lt;code&gt;vimproc&lt;/code&gt;もなくて大丈夫です。&lt;/p&gt;
&lt;p&gt;Pythonのバージョンは3.5で確認していますが、たぶん3.4でも動くと思います。&lt;/p&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;Vimで適当なmarkdownファイルを開き、&lt;code&gt;:LiveMark&lt;/code&gt;を実行してください。するとchromeが起動しますので、vimでファイルを編集したりカーソルを動かしたりしてみてください。リアルタイムで変更がブラウザ上に反映されるはずです。&lt;/p&gt;
&lt;p&gt;また、Vim上のカーソル位置も取得していますので、長い文章でブラウザの画面に収まらない場合、カーソル位置が画面に収まるようにいい感じ（自称）にスクロールします。&lt;/p&gt;
&lt;p&gt;スタイルが何もないと寂しいので、&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt; という日本語向けの Bootstrap テーマを同梱させていただきました&lt;sup id="fnref:honoka-cdn"&gt;&lt;a class="footnote-ref" href="#fn:honoka-cdn" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。日本語でもきれいに表示されると思います。&lt;/p&gt;
&lt;p&gt;終了する時は&lt;code&gt;:LiveMarkDisable&lt;/code&gt;です。何もしなくてもVimが終了した時にサーバープロセスは止まります。&lt;/p&gt;
&lt;h4&gt;手抜き感の漂うスクリーンキャスト・・・&lt;/h4&gt;
&lt;p&gt;&lt;img alt="screen cast" src="https://miyakogi.github.io/blog/images/livemark_sample.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;諸注意&lt;/h2&gt;
&lt;p&gt;エラーなどでPythonのプロセスが残ってしまう場合があります。その時はプロセスを殺してください。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:honoka-cdn"&gt;
&lt;p&gt;HonokaのCDNがわからなかったのでコードを含めています。
ライセンスはMITとのことなので大丈夫だとは思いますが、もし不都合ありましたらご一報ください。&amp;#160;&lt;a class="footnote-backref" href="#fnref:honoka-cdn" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Python"></category><category term="Vim"></category></entry></feed>