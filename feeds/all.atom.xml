<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Blank File</title><link href="https://miyakogi.github.io/blog/" rel="alternate"></link><link href="https://miyakogi.github.io/blog/feeds/all.atom.xml" rel="self"></link><id>https://miyakogi.github.io/blog/</id><updated>2016-02-29T17:52:00+09:00</updated><entry><title>Vimのパッケージ機能を試してみました</title><link href="https://miyakogi.github.io/blog/20160229/vim_pack.html" rel="alternate"></link><updated>2016-02-29T17:52:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-29:blog/20160229/vim_pack.html</id><summary type="html">&lt;p&gt;最近&lt;a href="https://github.com/Shougo/dein.vim"&gt;dein.vim&lt;/a&gt;がバズったりVim本体にパッケージ機能が追加されたり、Vim界隈は第二次プラグインマネージャ戦争の気配に包まれています &lt;em&gt;[要出典]&lt;/em&gt;。
dein.vimはすでにいくつか紹介記事がありますが、本体の方はあまり情報を見かけかなかったので先日試した結果を含めて紹介します。&lt;/p&gt;
&lt;p&gt;この機能は入ったばかりなので、今後仕様の変更があるかもしれませんし、バグもあるかもしれませんし、（たぶん）機能追加もあると思います。
記事の内容が古くなっているかもしれないので、日付とVimのバージョンをよく確認してください。&lt;/p&gt;
&lt;p&gt;試す人は本体のデバッグに自分のVimを捧げる気持ちでいきましょう。
バックアップ重要です。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;[2016/03/07: &lt;code&gt;:loadplugin&lt;/code&gt;が削除され&lt;code&gt;:packadd&lt;/code&gt;が追加されたので修正]&lt;/p&gt;
&lt;h2&gt;メリット&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;プラグインマネージャが裏で色々頑張ってくれていることが理解できる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;必要なもの&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最新のVim&lt;/li&gt;
&lt;li&gt;インストールするプラグイン&lt;/li&gt;
&lt;li&gt;たくさんエラーが出てもいいVim環境&lt;/li&gt;
&lt;li&gt;エラーやバグに負けない強い心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は Kubuntu 15.10 で試しました。
Vimのバージョンは7.4.1225くらいでした。&lt;/p&gt;
&lt;h3&gt;情報源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help packages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help :packadd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help 'packpath'&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;困ったら&lt;a href="https://github.com/vim/vim"&gt;ソースコード&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;とりあえずプラグインを入れてみる&lt;/h2&gt;
&lt;p&gt;プラグインを入れるディレクトリは大別して二種類です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/ever&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.vim/pack/{好きな名前}/opt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的には&lt;code&gt;ever&lt;/code&gt;以下に自動的に読み込んでほしいプラグインを置いて、&lt;code&gt;opt&lt;/code&gt;以下に必要な時に読み込む（遅延読込する）プラグインを置く形です。
すでにNeoBundleなどのプラグインマネージャを使っている場合はプラグインが一つのディレクトリにまとまっていると思いますので、その中身をまるっと&lt;code&gt;ever&lt;/code&gt;以下にコピーして&lt;code&gt;neobundle#begin()&lt;/code&gt;〜&lt;code&gt;neobundle#end()&lt;/code&gt;あたりを&lt;code&gt;if 0&lt;/code&gt;と&lt;code&gt;endif&lt;/code&gt;で囲めばすぐ試せます（微妙な仕様の違いがあるので、そのままだと大量のエラーを経験することになりますが）。&lt;/p&gt;
&lt;p&gt;例えばplugin1とplugin2を&lt;code&gt;ever&lt;/code&gt;以下に置く場合は次のようなディレクトリ構成になります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/.vim
├── pack
│   ├── mypack
│   │   ├── ever
│   │   │   ├── plugin1
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── README.md
│   │   │   ├── plugin2
│   │   │   │   ├── autoload
│   │   │   │   ├── plugin
│   │   │   │   └── readme.md
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;この状態でVimを起動すると、&lt;strong&gt;.vimrcなどを読み込んだ後に&lt;/strong&gt;自動的にplugin1とplugin2がruntimepathに追加されます。&lt;/p&gt;
&lt;p&gt;太字部分重要です。
つまりvimrcの中ではプラグインが定義するコマンドや関数は使えません。
例えば&lt;code&gt;NoeBundle ~&lt;/code&gt;とかやっていた部分は全滅します。
autoload関数も使えないので、設定で&lt;code&gt;call plugin#setup(...)&lt;/code&gt;などとしている部分も全滅です。
また、プラグインもロードされていないので、例えば&lt;code&gt;if neobundle#is_installed('プラグイン名')&lt;/code&gt;などのかわりに単純に&lt;code&gt;if get(g:, 'loaded_プラグイン名')&lt;/code&gt;などと置き換える事もできません。
値の設定（&lt;code&gt;let g:superplugin_default_option = 1&lt;/code&gt;など）は大丈夫です。&lt;/p&gt;
&lt;p&gt;私はこれを回避するために、プラグインを使っている部分を別ファイルに分離してオートコマンドで&lt;code&gt;VimEnter&lt;/code&gt;時に読み込むようにしました。
&lt;code&gt;~/.vim/after/plugin&lt;/code&gt;以下も試してみましたが、ここもパッケージのロードより先に読み込まれていました。
最終的にはプラグインを使う設定を&lt;code&gt;~/.vim/config/plugins.vim&lt;/code&gt;に書いて、次のような設定をvimrcに追加しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; filereadable&lt;span class="p"&gt;(&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/.vim/config/plugins.vim&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  autocmd myvimrc &lt;span class="nb"&gt;VimEnter&lt;/span&gt; * source &lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="sr"&gt;/.vim/&lt;/span&gt;config/plugins.&lt;span class="k"&gt;vim&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これで&lt;code&gt;plugins.vim&lt;/code&gt;の中ではプラグインが使えます。
インストールの確認も&lt;code&gt;if get(g:, 'loaded_~')&lt;/code&gt;や&lt;code&gt;if exists(':PluginCommand')&lt;/code&gt;などでできます。
&lt;code&gt;g:loaded_~&lt;/code&gt;を設定しないプラグインは、とりあえず&lt;code&gt;if match(&amp;amp;runtimepath, 'プラグイン名')&lt;/code&gt;で確認しています。&lt;/p&gt;
&lt;p&gt;注意する点は、オプション値の設定（&lt;code&gt;let g:~~~ = ...&lt;/code&gt;と設定するタイプ）はvimrc内に書いたほうが安全ということです。
読み込み時に設定値のチェックをしてそのまま使っているプラグインが結構あるようで、それらがロードされる前に値の設定を済ませる必要があるからです。&lt;/p&gt;
&lt;h3&gt;読み込まれないプラグイン対策&lt;/h3&gt;
&lt;p&gt;現在は&lt;code&gt;plugin&lt;/code&gt;ディレクトリがないプラグインは読み込まれない（runtimepathに追加されない）ようです。
これはautoload関数だけを提供しているプラグイン（&lt;a href="https://github.com/kana/vim-textobj-user"&gt;textobj-user&lt;/a&gt;など）やカラースキーム（&lt;a href="https://github.com/altercation/vim-colors-solarized"&gt;solalized&lt;/a&gt;など）、スニペット集（&lt;a href="https://github.com/Shougo/neosnippet-snippets"&gt;neosnippet-snippets&lt;/a&gt;）などが該当し、読み込まれません。
これが仕様として確定するのかわかりませんが、私はとりあえずの回避策として&lt;code&gt;mkdir plugin &amp;amp;&amp;amp; touch plugin/_.vim&lt;/code&gt;と適当にファイルを作って置きました。&lt;/p&gt;
&lt;p&gt;また、&lt;code&gt;plugin&lt;/code&gt;直下に&lt;code&gt;*.vim&lt;/code&gt;ファイルがなく、さらにディレクトリがあるようなプラグインも読み込まれませんでした。
仕様なのか微妙ですが、runtimepathには追加されているのでバグのような気がします。
ありがたいことに&lt;a href="https://github.com/vim-jp/issues/issues/848"&gt;動作確認とIssue報告&lt;/a&gt;までしていただいたので、7.5のリリースまでに修正されるのではないかと。。。
これも上記と同様に適当なファイル（&lt;code&gt;*.vim&lt;/code&gt;）をpluginディレクトリに置くことで読み込み可能です。&lt;/p&gt;
&lt;h2&gt;遅延読み込み&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;opt&lt;/code&gt;以下のプラグインはそのままでは読み込まれません。
&lt;code&gt;:packadd {プラグインのディレクトリ名}&lt;/code&gt;を実行して初めて有効になります。&lt;/p&gt;
&lt;p&gt;私はとりあえずインサートモードで使うプラグインを&lt;code&gt;opt&lt;/code&gt;に置き、以下のような設定を行いました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt; abort
  loadplugin delimitMate
  loadplugin &lt;span class="k"&gt;vim&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;smartchr
  loadplugin ...
  ...
&lt;span class="c"&gt;  &amp;quot; マッピングなどの設定があればする&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; s:init_delimitMate&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;  &amp;quot; 二回目以降実行されないようにautocmdを削除&lt;/span&gt;
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; lazy_load_i
&lt;span class="k"&gt;endfunction&lt;/span&gt;

augroup lazy_load_i
  autocmd&lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="nb"&gt;InsertEnter&lt;/span&gt; * &lt;span class="k"&gt;call&lt;/span&gt; s:lazy_load_insert&lt;span class="p"&gt;()&lt;/span&gt;
augroup END
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NeoBundleはコマンド実行や関数呼び出しやマッピングをトリガにして遅延読み込みできますが、大変そうだったのでそこまでやっていません。
起動時間に露骨に影響するようなプラグインはそもそも入れてないというのもありますが。
（NERDTreeやsyntasticは読み込みに結構時間かかるので使っていません）&lt;/p&gt;
&lt;h2&gt;起動時間&lt;/h2&gt;
&lt;p&gt;みなさん気になると思います。
ざっくり雑に測っただけですが、とりあえず遅延読み込みしないで全部読み込むような条件ではdein.vimと同じか少し速いくらい、NeoBundleより30~40%速い感じでした。
ただ、上に書いたように読み込まれないプラグインがけっこうあって、気づいたものは対策しましたがまだ読み込まれていないものもありそうなので、実際にはdein.vimと同じくらいじゃないかと思います。&lt;/p&gt;
&lt;p&gt;余談ですが、Vimの起動時間が気になる人は（もしやっていないなら）ファイルタイプの設定を自前で用意してデフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;を読まないようにするといいと思います。
デフォルトの設定だと人生で一度も使わないであろうファイルタイプの設定が大量にあるので。
デフォルトの&lt;code&gt;filetype.vim&lt;/code&gt;は&lt;code&gt;share/vim/vim74/filetype.vim&lt;/code&gt;にあります。
ここから必要そうな設定を拝借してvimrcで設定するなりして、&lt;code&gt;let g:did_load_filetypes=1&lt;/code&gt;しておけばデフォルトのファイルタイプ設定は読まれなくなります。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;NeoBundleがメンテナンスモードに入ると聞いてdein.vimへの移行を考えている方、どうせプラグイン周りの設定をいじるならついでに本体のパッケージ機能も試してみませんか？
いっしょに人柱してバグを探しましょう。&lt;/p&gt;</summary><category term="vim"></category></entry><entry><title>Python製の静的サイトジェネレータを色々試してみました</title><link href="https://miyakogi.github.io/blog/20160215/static_site_generators.html" rel="alternate"></link><updated>2016-02-15T15:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-15:blog/20160215/static_site_generators.html</id><summary type="html">&lt;p&gt;このブログははてなブログで運用していますが、最近ブログを静的サイトジェネレータで作ってGitHub Pagesにおこうかな、と考えています。
ということでいくつか静的サイトジェネレータを調べたのでまとめました。&lt;/p&gt;
&lt;p&gt;ついでに比較用に作ったブログをいくつかGitHub Pagesで公開しておきます。
内容はこのブログの過去数回分です。
同じテーマでも日本語だと雰囲気が違ったりするので、よかったら参考にしてください。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;ブログの移行を考えたきっかけは、はてなブログでgifファイルのアップロードができなかったからです。
それ以外は特に不満はないのですが、せっかくなので勉強がてら静的サイトジェネレータを使ってみようかと。&lt;/p&gt;
&lt;p&gt;私が静的サイトジェネレータに求める機能としては、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdownで書ける&lt;ul&gt;
&lt;li&gt;バッククォート３つでのコードブロックも対応&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一からデザインするのは無理なのでそれなりのテーマがある&lt;/li&gt;
&lt;li&gt;開発が続いている&lt;/li&gt;
&lt;li&gt;画像も扱える&lt;ul&gt;
&lt;li&gt;静的コンテンツへのリンクを開発環境と本番で変えられる&lt;/li&gt;
&lt;li&gt;例えば、開発時は http://localhost:8000/、本番は https://user.github.io/page/ とか&lt;ul&gt;
&lt;li&gt;本番環境でもドメインのルートに置けるなら気にならないと思います。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;トップに表示する記事の要約の範囲指定&lt;ul&gt;
&lt;li&gt;はてなブログの「続きを読む」的なやつ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;です。
あと、いざという時にコードを読んで対応できるように、自分の読めるPython製に絞って検討しました。
なのでJekyllやHugo、Hexoは検討していません。&lt;/p&gt;
&lt;p&gt;逆に重視しない機能は、運用（公開）の自動化や確認用のサーバーです。
GitHub Pagesで公開する場合はghp-importを使って&lt;code&gt;ghp-import [directory]&lt;/code&gt;して&lt;code&gt;git push origin gh-pages&lt;/code&gt;するだけなので、特になくてもいいかと。
サーバーも、ビルドするコマンドさえ提供されていれば&lt;a href="https://pypi.python.org/pypi/livereload"&gt;liveralod&lt;/a&gt;を使ったスクリプトを用意するので不要でした。&lt;/p&gt;
&lt;p&gt;今回検討した静的サイトジェネレータは以下の五つです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.getpelican.com/"&gt;Pelican&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/koenbok/Cactus"&gt;Cactus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.getlektor.com/"&gt;Lektor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.getnikola.com/"&gt;Nikola&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog_nikola/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mulholland.xyz/docs/ark/"&gt;Ark&lt;/a&gt; （&lt;a href="https://miyakogi.github.io/blog_ark/"&gt;サンプル&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にドキュメンテーションツールのSphinxやMkDocsでもhtmlを出力できますが、これらはブログ向けではないので候補から外しました。
Hydeも気になりましたが、サイトのデザインが好みでなかったのと面倒になったのでパスしました。&lt;/p&gt;
&lt;p&gt;以下、メモです。
結論としてはとりあえずPelicanを使ってみることにしたので、その前提でお願いします。
長いです。&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://docs.getpelican.com/"&gt;Pelican&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog/"&gt;日本語ブログのサンプル&lt;/a&gt; (&lt;a href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;をベースにフォントと文字サイズいじりました)&lt;/p&gt;
&lt;p&gt;Python製静的サイトジェネレータの中では最も有名で、GitHubのスターも一番多いです。
日本語でもPelicanでブログを作った記事はたくさんありました。&lt;/p&gt;
&lt;p&gt;テーマやプラグインが豊富でドキュメントも充実しているので、だいたいのことはなんとかなりそうです。
テーマは&lt;a href="http://www.pelicanthemes.com/"&gt;Pelican themes&lt;/a&gt;にスクリーンショット付きでたくさん紹介されています。&lt;/p&gt;
&lt;p&gt;使い方はすでにたくさん公開されているので割愛します。
基本的には&lt;code&gt;pelican-quickstart&lt;/code&gt; -&amp;gt; &lt;code&gt;content&lt;/code&gt;以下に記事追加 -&amp;gt; &lt;code&gt;make html&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;画像は&lt;code&gt;content/images&lt;/code&gt;ディレクトリに入れておけば出力先にコピーされます。
リンクする時は&lt;code&gt;{filename}/images/filename.png&lt;/code&gt;で、 &lt;code&gt;{filename}&lt;/code&gt;の部分はビルド時に設定した&lt;code&gt;SITE_URL&lt;/code&gt;で置き換えられます。
開発用と本番用の設定ファイルが分離されているので、開発用（pelicanconf.py）では&lt;code&gt;SITE_URL=''&lt;/code&gt;にしておいて、本番用（publishconf.py）で&lt;code&gt;SITE_URL='https://user.github.com/page/'&lt;/code&gt;のようにしておけば、開発（&lt;code&gt;make html&lt;/code&gt;）と本番（&lt;code&gt;make publish&lt;/code&gt;）でURLを切り替えられます。&lt;/p&gt;
&lt;p&gt;記事の要約はWord数で指定できるのですが、日本語だとwordカウントが微妙だったので自分で簡単なプラグインを書きました。&lt;/p&gt;
&lt;p&gt;テンプレートはJinja2なので、カスタマイズの敷居も低そうでした。
また、プラグイン用のフックが色々用意されているので、欲しい機能があったら自分で追加するのも簡単そうでした。&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/koenbok/Cactus"&gt;Cactus&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Djangoベースの静的サイトジェネレータです。
スター数は2600くらいでかなり多い方です。
デザイナー向けを謳っていて、記事の公開など運用面でかなりサポートしてくれる感じですが、今回そういう機能は不要です。&lt;/p&gt;
&lt;p&gt;インストールは普通に&lt;code&gt;pip install cactus&lt;/code&gt;でインストールされます。
使い方は、サイトの新規作成が&lt;code&gt;cactus create path&lt;/code&gt;で、ビルドは&lt;code&gt;cactus build&lt;/code&gt;、閲覧用サーバーの起動は&lt;code&gt;cactus serve&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;ドキュメントは見つかりませんでした。
GitHubのREADMEにかなり書かれているので、それで十分ということなのでしょうか？
チュートリアルのビデオはありましたが、README以上の情報はありませんでした。&lt;/p&gt;
&lt;p&gt;Django使うとなんか大げさな気がしてそれだけで少し敬遠してしまいました・・・
あと &lt;code&gt;cactus serve&lt;/code&gt; でサーバーを立ち上げたらいきなりエラーになって印象悪かったです・・・
設定ファイルがjsonなのも個人的には微妙でした。&lt;/p&gt;
&lt;p&gt;デフォルトではブログというよりもポートフォリオサイトのようなものが作られます。
ブログも作れるということでブログの例が&lt;a href="https://github.com/koenbok/CactusBlog/"&gt;公開されている&lt;/a&gt;のですが、これ記事も全部html（djangoテンプレート）で書かれています・・・
Markdown使いたかったら自分でビルドスクリプト書けということでしょうか・・・
一応プラグインサポートもあるのかな？
誰も考えていないわけではなさそうです（&lt;a href="https://github.com/koenbok/Cactus/pull/96"&gt;First pass at Markdown-only blog posts&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;ということで、デザインはいい感じだったのですが手軽にブログが書ける感じではなかったので見送ります。&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.getlektor.com/"&gt;Lektor&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;昨年末に公開された新しい静的サイトジェネレータです。
作者はFlaskやJinja2、clickなど有名なpythonパッケージを作っているArminさんです。
Flaskを作った方ということで、拡張性・柔軟性も強く意識しているようです。
ドキュメントも充実しています。
ただ、まだptyhon3で動かないみたいですね・・・これは厳しい・・・
Issueは立っていたので、すぐサポートされると思います。&lt;/p&gt;
&lt;p&gt;これは普通の静的サイトジェネレータとは毛色が異なります。
記事を書いたり画像などのリソースを追加したり、コンテンツの管理は基本的に管理画面または&lt;a href="https://www.getlektor.com/downloads/"&gt;専用のアプリ&lt;/a&gt;から行うようです。
ローカルでhtmlファイルを出力するという意味では静的サイトジェネレータなのですが、運用面ではWordPressなどのCMSに近い感じです。&lt;/p&gt;
&lt;p&gt;コマンドラインから操作する場合は、まず&lt;code&gt;lektor quickstart&lt;/code&gt;でプロジェクトを作って、そこで&lt;code&gt;lektor server&lt;/code&gt;するとサーバーが立ち上がります。
&lt;code&gt;http://localhost:5000&lt;/code&gt;にアクセスすると&lt;s&gt;寂しい感じの&lt;/s&gt;ページが表示されると思います。
&lt;code&gt;http://localhost:5000/admin&lt;/code&gt;にアクセスすると管理画面が開いて、そこから記事の追加などが行えます。&lt;/p&gt;
&lt;p&gt;記事本文はMarkdownで書けます。
管理画面からプレビューもできます。
記事のデータはテキストで保存されるのですが、&lt;code&gt;.lr&lt;/code&gt;という専用？のフォーマットです。
直接テキストを編集するような使い方はあまり想定されていないのかもしれません。&lt;/p&gt;
&lt;p&gt;公開されたばかりなので、テーマが少ないのは仕方ないと思います。
テンプレートエンジンは当然Jinja2なので、自分で作るのも難しくはないと思います。&lt;/p&gt;
&lt;p&gt;私はVimで記事を書きたかったので見送りました。
WordPressのような感じで管理画面から記事を投稿したい人や、複数人で共同してサイトを作成する場合などはいいかもしれません。
まだできたばかりなので、興味ある人は今から使ってテーマやプラグインを作ると第一人者になれますよ！&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://www.getnikola.com/"&gt;Nikola&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog_nikola/"&gt;日本語ブログのサンプル&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;普通の静的サイトジェネレータです。
python-announce-listに頻繁に更新メールが送られてくるので、開発は活発だと思います。&lt;/p&gt;
&lt;p&gt;Pelicanよりもマイナーなのでテーマや情報は少ないです。
&lt;a href="https://getnikola.com/handbook.html"&gt;ドキュメント&lt;/a&gt;は非常に充実しているので、使う上で困ることはそんなになさそうです。
機能は豊富だと思います。&lt;/p&gt;
&lt;p&gt;デフォルト（デモ？）のサイトを作るのは&lt;code&gt;nikola init --demo [path]&lt;/code&gt;です。
後は&lt;code&gt;nikola build&lt;/code&gt;とか&lt;code&gt;nikola serve&lt;/code&gt;でビルドしたり閲覧用のサーバーを起動したりできます。
デフォルトのフォーマットはrstですが、設定ファイル(conf.py)に以下の行を追加することでmarkdownも使えます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;POSTS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.md&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;# ここを追加&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.rst&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;posts/*.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;posts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;post.tmpl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;nikola new_post&lt;/code&gt;で新しい記事が作れるのはいいですね。
どの静的サイトジェネレータもタイトルや日付などのメタデータを入力する必要があったのですが、フォーマットを覚えてられないので他の記事からコピペして使うのが地味に面倒でした。
（Pelicanはプラグインとかありそうですが、見つからなかったのでスクリプトを書きました。）&lt;/p&gt;
&lt;p&gt;画像などの静的ファイルは&lt;code&gt;files&lt;/code&gt;ディレクトリに放り込めば出力先にコピーされます。
困ったのはコンテンツへのリンクでした。
設定ファイルの&lt;code&gt;SITE_URL&lt;/code&gt;でサイトのURLを指定するとそこを起点としたリンクが作成されるのですが、これを開発環境と本番環境で切り替える方法がわかりませんでした。
組み込みのサーバ(&lt;code&gt;nikola serve&lt;/code&gt;)を立ち上げてローカルで確認する場合はローカルのリンクに変換されているようなので、これを使えばそんなに不便はないと思います。
私は組み込みのサーバーを使わずにlivereloadでファイルの変更を検出して自動でビルド・ブラウザのリロードまでしたかったのですが、ちょっとその方法はわかりませんでした。&lt;/p&gt;
&lt;p&gt;記事の要約は、区切りとなるコメントを挿入することで範囲を指定できます。
Markdownの場合、デフォルトでは&lt;code&gt;&amp;lt;!-- TEASER_END --&amp;gt;&lt;/code&gt;というコメントまでが要約になります。
はてなブログと同じ&lt;code&gt;&amp;lt;!-- more --&amp;gt;&lt;/code&gt;を使いたかったので、設定ファイルで以下のように設定しました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;INDEX_TEASERS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;TEASER_REGEXP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r&amp;#39;&amp;lt;!--\s*(more)(:(.+))?\s*--&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;今回見送った理由は、上記の理由の他に、ビルドにかかる時間が他より長く感じたからです。
長いと言っても数秒で終わるのですが、なんとなく不安を感じて。
あと、なんかプロジェクトのロゴが残念な感じだったので。&lt;/p&gt;
&lt;p&gt;サンプルを見ていただければわかりますが、デフォルトのbootstrapを使ったデザイン結構いい感じです。
珍しいものでサイトを作りたい人にはいいかもしれません。&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://mulholland.xyz/docs/ark/"&gt;Ark&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://miyakogi.github.io/blog_ark/"&gt;日本語ブログのサンプル&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;めっちゃマイナーです（githubのスター20個くらい）。
つい最近pypiに登録されたばかりです。&lt;/p&gt;
&lt;p&gt;実は静的サイトジェネレータでブログを作ろうかと思ったきっかけの一つはこれです。
デフォルトのテーマがかっこいいんですよ。
WordPressのtwentyfifteenがベースらしいのですが、WordPressはこんなにかっこいいテーマがすぐ使えるんですね、人気なの納得しました。&lt;/p&gt;
&lt;p&gt;機能はシンプルです。
新しいので情報はないに等しいと思うのですが、&lt;a href="http://mulholland.xyz/docs/ark/guide.html"&gt;ドキュメント&lt;/a&gt;が充実しているので意外と普通に使えました。
むしろドキュメントが充実していて機能もシンプルなので、CactusやLektorよりとっつきやすかったです。&lt;/p&gt;
&lt;p&gt;使い方は簡単で、&lt;code&gt;pip install ark&lt;/code&gt; でインストールして &lt;code&gt;ark init&lt;/code&gt; すると必要なファイルが用意されます。
あとは &lt;code&gt;ark build&lt;/code&gt; すれば out ディレクトリに出力されます。
とはいえ、いざとなったらソースを読む覚悟は必要です。
今回、サイトのタイトルを設定する方法がわからなかったのでソース眺めましたが、設定ファイルに&lt;code&gt;title='タイトル'&lt;/code&gt;で設定出来ました。
このあたりはテーマ（テンプレート）次第な気もしますが。&lt;/p&gt;
&lt;p&gt;ブログ記事は &lt;code&gt;src/[posts]&lt;/code&gt; ディレクトリに置くだけです。
新規記事の作成や既存記事の編集はコマンドも用意されていて、&lt;code&gt;ark edit posts filename&lt;/code&gt;で作成・編集できます。
各記事はMarkdownで書けて、ファイルの最初にメタデータとしてタイトル、日付を書き、後は本文を書くだけです。
メタデータには著者やタグなども書けます。
コマンドから作成した時は時刻が入力されています。&lt;/p&gt;
&lt;p&gt;Markdownの拡張はconfig.pyに以下の設定を追加する必要がありました。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;extensions&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fenced_code&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;codehilite&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;extra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;画像などは&lt;code&gt;src&lt;/code&gt;以下のディレクトリに置けば出力時にコピーされます。
ディレクトリも追加可能なので、&lt;code&gt;src/images&lt;/code&gt;などのディレクトリを作っておけば同じ構造で出力されます。
リンクは&lt;code&gt;@root/&lt;/code&gt;で始めれば設定ファイル（config.py）で指定するサイトのルートURLに置き換えられます。
ルートURLを開発用と本番用で切り替えるコマンドなどはないようですが、ルートURLを空（&lt;code&gt;root=""&lt;/code&gt;）にしておくと上記の&lt;code&gt;@root/&lt;/code&gt;の部分を相対リンクに変換してくれるので、特に問題なく使えました。&lt;/p&gt;
&lt;p&gt;正直かなり惹かれました。
作者の方は（これ用なのかわかりませんが）Markdownの方言？的なもの（&lt;a href="https://github.com/dmulholland/syntex"&gt;Syntex&lt;/a&gt;）やDjango/Jinja風のテンプレートエンジン（&lt;a href="https://github.com/dmulholland/ibis"&gt;Ibis&lt;/a&gt;）も作って公開しています。
このジェネレータはそれらの形式もサポートしていますが、今回は興味なかったので内容は確認しませんでした。
デフォルトでMarkdownやJinja2もサポートしているので実用上問題ありません。&lt;/p&gt;
&lt;p&gt;採用しなかった理由は、さすがにマイナー過ぎて今後が心配なことと、記事の要約を出力する機能がみつからなかったことです。
プラグインの機構はあるので拡張で作れそうですが、要約出力から作る必要がありそうで、ちょっとめんどくさそうでした。
よく見たら記事のアーカイブもない？
設定で出せるんでしょうか。
タグ一覧は設定があったので出せると思います（未確認）。&lt;/p&gt;
&lt;p&gt;ブログ用に使うのはまだちょっと厳しい感じでした。
小さなプロジェクトのページくらいなら使えそうな気がします。&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;結局Pelicanを使ってみることにしました。
テーマが豊富なのは大きいです。
せっかくなのでマイナーなものとか新しいものに挑戦したかったのですが、結局無難なところに落ち着いてしまって悲しい・・・
Arkは何かのプロジェクトページで使うかもしれません。&lt;/p&gt;
&lt;h3&gt;あとがき&lt;/h3&gt;
&lt;p&gt;この記事書いてたらmattnさんがJekyll 3.0の記事を公開していました。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mattn.kaoriya.net/software/20160215110235.htm"&gt;Big Sky :: GitHub Pages が Jekyll 3.0 になり、ますますブログが書きやすくなった。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jekyllも便利そうです。&lt;/p&gt;</summary><category term="python"></category><category term="pelican"></category><category term="static site generator"></category></entry><entry><title>Livemark.vimを色々更新しました</title><link href="https://miyakogi.github.io/blog/20160214/livemark_update.html" rel="alternate"></link><updated>2016-02-14T13:14:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-14:blog/20160214/livemark_update.html</id><summary type="html">&lt;p&gt;Markdown文書をリアルタイムで更新するVimプラグイン、&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;Livemark.vim&lt;/a&gt;を更新しました。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+channel&lt;/code&gt;なVimじゃなくても&lt;code&gt;+python&lt;/code&gt;なら動作するので、よければお試し下さい。
安定したものがいい場合は&lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt;などをおすすめします。&lt;/p&gt;
&lt;p&gt;オプションはGitHubの&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;README&lt;/a&gt;に一応全て書いてあります。
まだバグがあるかもしれませんが、その時は&lt;a href="https://github.com/miyakogi/livemark.vim/issues"&gt;Issue&lt;/a&gt;に報告していただけると喜んで対応します。Issueを書くのが面倒でしたら、Twitterで&lt;a href="https://twitter.com/MiyakoDev"&gt;@MiyakoDev&lt;/a&gt;にメンションしていただいても大丈夫です。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h3&gt;変更点&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://h-miyako.hatenablog.com/entry/2016/02/06/135203"&gt;先日の記事&lt;/a&gt;以降に追加した機能（オプション）は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ユーザー指定のcss/jsを読み込む設定追加&lt;/li&gt;
&lt;li&gt;シンタックスハイライトのテーマ指定追加&lt;/li&gt;
&lt;li&gt;プレビュー画面のスクロール同期を止めるオプション追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ついでに、Pythonで書かれたプレビュー用のサーバー部分を&lt;a href="https://github.com/miyakogi/livemark"&gt;別リポジトリ&lt;/a&gt;に分離しました。
まだ分離しただけに近い状態ですが、機能を整理してドキュメントやテストを追加して、Vim以外のエディタからも使えるような形にできたらいいなぁ、と思っています。&lt;/p&gt;
&lt;h4&gt;CSS/JSファイルの読み込み&lt;/h4&gt;
&lt;p&gt;デフォルトでは日本語向けBootstrapテーマの&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt;を読み込んでいます。
それに伴い、CDNからjQueryもロードしています。&lt;/p&gt;
&lt;p&gt;ちょっと使うには十分だと思いますが、自分のブログのテーマと同じデザインで使いたいなどの希望があるだろうと考え、CSSやJSを指定できるようにしました。
パスの処理が雑なので、Windowsだと動かないかもしれません。&lt;/p&gt;
&lt;p&gt;指定方法は、例えばCSSを追加してデフォルトのCSSを使わない場合は以下のようになります。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_css_files &lt;span class="p"&gt;=&lt;/span&gt; [expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/dotfiles/static/css/bootstrap.ja.min.css&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_no_default_css &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;複数のCSSファイルを指定したい場合はそれぞれリストに追加してください。
リストに追加された順番で読み込みます。
URLを指定すれば（たぶん）Web上のリソースを読み込むこともできます。
その場合はURLを指定してください。
例えば、&lt;code&gt;let g:livemark_css_files = ['https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js']&lt;/code&gt;のような感じです。&lt;/p&gt;
&lt;p&gt;デフォルトのCSSを使用し、CSSを追加したいだけの場合は二行目は不要です。
その場合、ブラウザ上での読み込み順は デフォルトのCSS -&amp;gt; 追加されたCSSの順になります。&lt;/p&gt;
&lt;p&gt;JSについても同様です。各オプションの&lt;code&gt;css&lt;/code&gt;を&lt;code&gt;js&lt;/code&gt;に変更してください。&lt;/p&gt;
&lt;h4&gt;シンタックスハイライトのテーマ設定&lt;/h4&gt;
&lt;p&gt;シンタックスハイライトには&lt;a href="http://pygments.org/"&gt;pygments&lt;/a&gt;を使っています。
デフォルトでは特に指定していないのでpygmentsのデフォルトテーマが使われますが、他にも色々なテーマがあるので変更できるようにしました。&lt;/p&gt;
&lt;p&gt;変更するには以下の設定をvimrcに追加してください。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_highlight_theme &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;テーマ名&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用可能なテーマはインストールされているpygmentsに依存します。
コマンドラインで確認するには、以下のコマンドを実行して下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -c &lt;span class="s2"&gt;&amp;quot;import pygments.styles; print(pygments.styles.STYLE_MAP.keys())&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示されたキーが利用可能なテーマ名です。
Livemarkのオプションで特定のpythonを指定している場合はpython3の部分をそちらに変えてください。&lt;/p&gt;
&lt;h4&gt;スクロールの同期を止めるオプションの追加&lt;/h4&gt;
&lt;p&gt;デフォルトではVimのカーソル位置に応じて画面をスクロールしています。
具体的には、Vimのバッファに表示されている最初の行が画面の最上部に来るように調整しています。&lt;/p&gt;
&lt;p&gt;とはいえ、MarkdownからHTMLに変更する時に行番号がずれてしまうので、一応頑張って調整していますが完璧ではありません。
また、書いている時に動かない方がいい場合もあるかと思います。&lt;/p&gt;
&lt;p&gt;ということで、以下のオプションでスクロールを停止できます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:livemark_disable_scroll &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内部的な話&lt;/h3&gt;
&lt;p&gt;内部的にはかなり大きな変更を行いました。&lt;/p&gt;
&lt;p&gt;当初はカーソル移動やテキストの編集が行われるたびに全文をhtmlにパースし、プレビュー画面全部を書き換えるという力技で実装されていたのですが、さすがにこれだと大きなファイルの時に描画の遅れが深刻だったので修正しました。
今は差分を検出して変更のあった部分だけを更新しています。
個人的にはJSツラいのでJSではなくPythonで処理しました。&lt;/p&gt;
&lt;p&gt;ちょうど今&lt;a href="https://github.com/miyakogi/wdom_py"&gt;wdom&lt;/a&gt;というPythonからブラウザ上のDOMを操作するライブラリを開発しているので、これを使ってHTMLからDOMにパースして変更箇所だけをブラウザ上で変更、という処理にしています。Livemark用のJSはスクロール用の関数を数行書いただけで、他はPythonで実装できました。変更がない時はHTMLへの変換も行わないので、カーソル移動はかなりスムーズになったと思います。&lt;/p&gt;
&lt;p&gt;なお、このライブラリ（wdom）は絶賛開発途中です。
Livemarkにバグがあっても「まぁ、そういう時もあるよね」という温かい心で接してください。&lt;/p&gt;
&lt;p&gt;ちなみに、wdomで目指すところはほぼJSフリーでelectron/ブラウザを使ったGUIアプリの開発です。
昨年からelectronが流行ってますけど、JSでデスクトップアプリ作りたい人だけじゃなくて、CSSフレームワーク（Bootstrapとか）のために渋々JS書いてる人も多いんじゃないの？というのが開発の動機です。
&lt;s&gt;つまり既存のGUIライブラリは見た目が残念・・・&lt;/s&gt;
今はLivemarkで色々使ってみて、必要な機能の確認とバグを洗い出している感じです。
なのでまだドキュメントもありませんし、APIも変わる可能性があります。
落ち着いたらPyPIに登録して &lt;strong&gt;「まだじゃわすくりぷとで消耗しているの？」&lt;/strong&gt; 的な煽りタイトルの記事を書きたいと思っています。
ヘタれたらもっと穏便なタイトルにするので優しくしてください。&lt;/p&gt;
&lt;p&gt;以上です。
開発中のものを色々取り入れているのでバグがある可能性大ですが、人柱精神旺盛な方、よろしければお試しください。&lt;/p&gt;</summary><category term="vim"></category><category term="python"></category></entry><entry><title>カバレッジ取得サービスの比較（Coveralls.ioとCodecove.io)</title><link href="https://miyakogi.github.io/blog/20160206/ci1.html" rel="alternate"></link><updated>2016-02-06T17:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-06:blog/20160206/ci1.html</id><summary type="html">&lt;p&gt;※ 注意：この記事には主観とグチが含まれています。&lt;/p&gt;
&lt;p&gt;コードのカバレッジ取得サービスを調べてみました。&lt;a href="https://coveralls.io/"&gt;Coveralls.io&lt;/a&gt;と&lt;a href="https://codecov.io/"&gt;Codecov.io&lt;/a&gt;の比較です。&lt;/p&gt;
&lt;p&gt;↓こんな感じのバッジがREADMEに表示されるやつです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://codecov.io/github/miyakogi/coveralls_sample?branch=master"&gt;&lt;img alt="codecov.io" src="https://codecov.io/github/miyakogi/coveralls_sample/coverage.svg?branch=master" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;TravisCIなどで自動テストを行い、ついでにテストのカバレッジも取得している方は多いと思います。
カバレッジを取得できるCIサービスだと coveralls を使っているプロジェクトが多いようですが、自分が試した時はなんか反応が鈍かったりgithubのリポジトリの更新が上手く反映されなかったり...とあまりいい印象がなかったので、他のサービスも試して比べてみました。他というか&lt;a href="https://codecov.io/"&gt;Codecov&lt;/a&gt;しか試してませんが。Codecovは&lt;a href="http://blog-ja.sideci.com/entry/2016/01/13/110000"&gt;SideCIさんのブログ記事&lt;/a&gt;で知りました。ありがとうございます。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;結論：&lt;a href="https://codecov.io/"&gt;Codecov&lt;/a&gt;いい感じ！おすすめですよ！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;利用方法&lt;/h2&gt;
&lt;p&gt;どちらも公開リポジトリは無料です。プライベートリポジトリは有料プランになります。&lt;/p&gt;
&lt;p&gt;公開リポジトリの使い方はどちらも大差ありません。Githubのアカウント連携で認証して、連携したいリポジトリを指定して、Travisとも連携してテスト後にそれぞれのサービス向けに用意されているコマンドを叩くだけです。Travis + Pythonの場合、&lt;code&gt;.travis.yml&lt;/code&gt;に以下のように設定します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;pip install pytest pytest-cov&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;pip install coveralls codecov&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;script&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;py.test --cov [module or package]&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;after_success&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;coveralls&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;codecov&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;インストールの二行目で両方のサービス用のパッケージをインストールして、after_successのところでそれぞれのサービス用のコマンドを実行して結果を送信しています。&lt;/p&gt;
&lt;p&gt;実際には使う方のサービスだけ設定すればOKです。ってゆーかですね、coverallsはこれだけで済むということに気づくまで結構時間がかかりました。&lt;/p&gt;
&lt;h4&gt;以下、しばらくcoverallsへの愚痴です&lt;/h4&gt;
&lt;p&gt;下の画像はcoverallsのドキュメントのpythonの説明です。本当にこれだけです。やる気が感じられません。好みじゃないのでリンクは貼りません。対応言語は結構たくさんありました。Rubyとかはドキュメントも結構充実してました。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls python document" src="https://miyakogi.github.io/blog/images/coveralls_pydoc.png" /&gt;&lt;/p&gt;
&lt;p&gt;まずpypiにcoveralls用のパッケージが二つあります。coverallsとpython-coverallsです。よくわからないのでざっくり説明を見た結果、おそらく大差ありません。coverallsの方がユーザーが一桁くらい多そうでした。公式が一つだけ用意してそれだけドキュメントに書いておいてくれればいいのに・・・&lt;/p&gt;
&lt;p&gt;また、coverallsの説明にはテストを走らせたあとに&lt;code&gt;coverage run&lt;/code&gt;を実行してカバレッジを計算すると説明があるのですが、&lt;code&gt;py.test&lt;/code&gt;を使った場合の説明がありません。私はpytestでテストを走らせてpytest-covというパッケージでテストと同時にカバレッジを取得していたので、追加でさらにcoverageを走らせるのか、スキップするテストの設定はどうするのか、カバレッジの計算から除外するモジュールの設定はどうするのか、などの情報がなくて困りました。実際にはpytest-covがcoverageを走らせているっぽいので特に何もしなくてよかったのですが。これは自分の知識不足が悪いのですが。。。情報少ない。。。そもそもトライするためのリポジトリをgithubに作っても、タイミングが悪かったのかgithubの更新が上手く取得できず、かなりストレスを感じました。&lt;/p&gt;
&lt;h4&gt;一方、codecovは&lt;/h4&gt;
&lt;p&gt;他の言語の説明でも結果のレポートはpipでインストールしたcodecovを使っていたので、pythonメインでやっている企業という印象です。&lt;a href="https://github.com/codecov/example-python"&gt;公式のリポジトリ&lt;/a&gt;には必要十分な説明がって、すぐに使えました。&lt;code&gt;coverage&lt;/code&gt;を使う方法、&lt;code&gt;nosetest&lt;/code&gt;を使う方法、&lt;code&gt;pytest&lt;/code&gt;を使う方法全て書かれています。また、Travisとの連携やCircleCIとの連携も書かれています。&lt;/p&gt;
&lt;h2&gt;両サービスの比較&lt;/h2&gt;
&lt;p&gt;比較用のリポジトリをGithubに用意しました。それぞれのバッジから対象サービスを開けます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/miyakogi/coveralls_sample"&gt;miyakogi/coveralls_sample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;バッジのデザインは大差ありません。カバレッジが表示されて、カバレッジが低いと赤っぽい色になります。&lt;/p&gt;
&lt;h3&gt;リポジトリのページ&lt;/h3&gt;
&lt;p&gt;バッジから対象リポジトリの結果を開いたところです。（上：coveralls、下：codecov）
どちらも全体のカバレッジはすぐわかるように大きく表示されています。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls repository top" src="https://miyakogi.github.io/blog/images/coveralls_top.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov repository top" src="https://miyakogi.github.io/blog/images/codecov_top.png" /&gt;&lt;/p&gt;
&lt;p&gt;Coverallsはビルド毎のカバレッジ変化が表示されているのですが、個別のファイルのカバレッジはパッと見ではわかりません。ここからさらにリンクをクリックしてページ遷移する必要があります。&lt;/p&gt;
&lt;p&gt;Codecovは最新のカバレッジしか表示されていませんが、個別のファイルのカバレッジも最初から表示されており、問題のあるファイルがすぐにわかります。この表示はツリー形式とリスト形式で切り替え可能です。また、ビルド毎のカバレッジの変化をグラフ表示する機能もあります（後述）。&lt;/p&gt;
&lt;h3&gt;テスト漏れ箇所の表示&lt;/h3&gt;
&lt;p&gt;どちらのサービスも行ベースでテストされている/されていない箇所を表示する機能があります。
むしろこの機能のためにカバレッジ取得サービスを使うようなものなので、ないと話になりません。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coveralls file view" src="https://miyakogi.github.io/blog/images/coveralls_file.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov file view" src="https://miyakogi.github.io/blog/images/codecov_file.png" /&gt;&lt;/p&gt;
&lt;p&gt;テストされている行は緑、されていない行は赤くなっています。
色に関しては好みの範囲だと思いますが、私はcodecovの方が違いがわかりやすくて好きです。&lt;/p&gt;
&lt;p&gt;ちなみに、個別のファイルの結果を表示させるまでのクリック数は、Githubのリポジトリから&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coveralls&lt;ul&gt;
&lt;li&gt;バッジ→ ビルド番号か何かクリック→ ファイル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;codecov&lt;ul&gt;
&lt;li&gt;バッジ→ ファイル&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となっていてcodecovの方がファイルへのアクセスはしやすくなっています。その上、ユーザーが少ないからなのか、codecovの方がページを開くのが速くて快適です(体感)。&lt;/p&gt;
&lt;p&gt;また、codecovは&lt;a href="https://github.com/codecov/browser-extension#codecov-extension"&gt;Chrome, Firefox, Opera向けのブラウザ拡張機能&lt;/a&gt;が用意されています。この拡張をインストールすると、Githubでcodecovと連携しているリポジトリのファイルを開いた時にテストの状況が表示されるようになります。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov github extension" src="https://miyakogi.github.io/blog/images/codecov_github.png" /&gt;&lt;/p&gt;
&lt;p&gt;邪魔な時は「Coverage xx.xx%」のところをクリックすれば消せます。
Github上でカバレッジが確認できるのはポイント高いと思います。
見た目もいい感じです。&lt;/p&gt;
&lt;h3&gt;その他の機能&lt;/h3&gt;
&lt;p&gt;Codecovはslackなどへの通知機能もあるようです。Coverallsもあるのかもしれませんがよくわかりません。&lt;/p&gt;
&lt;p&gt;Codecovはリポジトリのページにビルド毎のカバレッジ変化が表示されていませんでしたが、カバレッジの変化をグラフ表示する機能があります。前述のサンプルリポジトリのグラフはこれです。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov.io" src="https://codecov.io/github/miyakogi/coveralls_sample/branch.svg?branch=master" /&gt;&lt;/p&gt;
&lt;p&gt;バッジのようにMarkdownやHTMLで簡単に貼り付けることができます。上のグラフのMarkdownはこんな感じです。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;![codecov.io](https://codecov.io/github/miyakogi/coveralls_sample/branch.svg?branch=master)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;バッジやグラフのMarkdown表示などはここから取得できます。&lt;/p&gt;
&lt;p&gt;&lt;img alt="codecov graph code" src="https://miyakogi.github.io/blog/images/codecov_getgraph.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;サイトのデザインは全体的にとてもオシャレな感じなのですが、なぜグラフだけこんなに残念な感じなのでしょうか。エクセルでももう少しマシなグラフを書いてくれそうです。しかも下部の会社名の所、見事にデザインが崩れています。改善を期待しています。。。&lt;/small&gt;&lt;/p&gt;
&lt;h2&gt;まとめ&lt;/h2&gt;
&lt;p&gt;というわけで、全体的にcoverallsが印象悪かったせいでcodecovの広告記事みたいになってしまいましたが、codecov良かったのでしばらく使うつもりです。&lt;/p&gt;
&lt;p&gt;Codecovいい感じなのでよかったら検討に加えてみてください。私は本当にcodecovと関係ないのですが、この分野かなり生き残り厳しいので (TravisやCircleCI以外の消えていったCIサービスは数知れません)、サービス終了されて渋々coverallsへ移行するという状況は避けたいのです・・・よろしくお願いします・・・&lt;/p&gt;
&lt;p&gt;長文にお付き合いいただきありがとうございました。参考になれば幸いです。&lt;/p&gt;</summary><category term="Python"></category><category term="CI"></category></entry><entry><title>Vim の channel と json のパフォーマンス</title><link href="https://miyakogi.github.io/blog/20160206/channel1.html" rel="alternate"></link><updated>2016-02-06T10:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-02-06:blog/20160206/channel1.html</id><summary type="html">&lt;p&gt;先日公開した &lt;a href="https://github.com/miyakogi/livemark.vim"&gt;livemark.vim&lt;/a&gt; には想像以上にたくさんの反響をいただきました。
ありがとうございます。
最近では海外の方からもGithubのスターをいただきました。
思いつきで作ったプラグインでしたが、せっかくなので普段使いできるようにいくつか更新しました。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;ul&gt;
&lt;li&gt;channel をサポートしない vim では python を使うように修正&lt;ul&gt;
&lt;li&gt;channelをサポートするvimでもpythonを使いたい場合は &lt;code&gt;let g:livemark_force_pysocket=1&lt;/code&gt; で使えます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;マークダウンの変換及びプレビュー表示をするpythonを指定する設定追加&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_python='/path/to/python'&lt;/code&gt; で指定できます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビューを表示するブラウザを vim から設定できるように修正&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let g:livemark_browser='[ブラウザ名]'&lt;/code&gt; で設定できます&lt;/li&gt;
&lt;li&gt;設定可能なブラウザと名前は&lt;a href="http://docs.python.jp/3/library/webbrowser.html#webbrowser.register"&gt;ここ&lt;/a&gt;を参照してください&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビュー表示に使うポートと vim からデータを送るために使うポートの設定を追加&lt;ul&gt;
&lt;li&gt;それぞれ &lt;code&gt;g:livemark_browser_port&lt;/code&gt; と &lt;code&gt;g:livemark_vim_port&lt;/code&gt; です&lt;/li&gt;
&lt;li&gt;デフォルト値はそれぞれ 8089, 8090 です&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;とはいえ、まだ安定しているとは言いがたい状態なので、マークダウンのプレビューには &lt;a href="https://github.com/kannokanno/previm"&gt;previm&lt;/a&gt; などを使うのがいいと思います。&lt;/p&gt;
&lt;p&gt;今の実装だと変更がある度に画面全体を再描画していて大きいファイルのプレビューは厳しいので、差分だけ更新するような処理を実装中です。&lt;/p&gt;
&lt;p&gt;そんな感じで地味に更新したりしてたのですが、&lt;a href="http://ftp.vim.org/vim/patches/7.4/7.4.1244"&gt;このパッチ&lt;/a&gt;でchannel関係の関数名が全部変わったので動かなくなりました（つらい&lt;/p&gt;
&lt;p&gt;&lt;img alt="channel error" src="https://miyakogi.github.io/blog/images/channel_error.png" /&gt;&lt;/p&gt;
&lt;p&gt;修正してもまた仕様変更あったら面倒だなぁ、と微妙にやる気が減退気味だったのと、pythonでデータ送ってもそんなにもたつきを感じなかったりして「もしかして Vim の channel より python の方が速い・・・？いや channel も json も C で書かれてるしそんなはずは・・・でも Vim だし何が起きるかわからん」という疑問が沸き起こったので測ってみました。&lt;/p&gt;
&lt;p&gt;Livemark.vim では編集中のバッファの文字列を取得して json として送っているので、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;データをjsonに変換する処理&lt;/li&gt;
&lt;li&gt;変換されたデータをサーバーに送りつける処理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;に分けて計測しました。また、Vimは一旦jsonに変換してから送る場合 (raw channel) とjsonへの変換も一気に行う場合 (json channel) の両方を測りました。&lt;/p&gt;
&lt;p&gt;データを送りつけられるサーバーがボトルネックになると意味ないので、サーバーは Nim で書きました。 サーバーのコードはこんな感じです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;nativesockets&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;net&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Port&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bindAddr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newSocket&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;accepted&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kp"&gt;true&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res_client&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;connection closed&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;

&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ベンチマークのコードはこんな感じ&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;scriptencoding&lt;/span&gt; utf&lt;span class="m"&gt;-8&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; s:data &lt;span class="p"&gt;=&lt;/span&gt; readfile&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;data.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;EOF
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;vim&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s:data&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_vim&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jsonencode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;json_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_raw&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;raw&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_sendraw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;ch_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;endfunction&lt;/span&gt;

&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;send_data_py&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;abort&lt;/span&gt;
  &lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;
&lt;span class="c1"&gt;# data = json.dumps(vim.eval(&amp;#39;s:data&amp;#39;)).encode(&amp;#39;utf-8&amp;#39;)&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_connection&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8090&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;json_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
EOF
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt; abort
  &lt;span class="k"&gt;let&lt;/span&gt; handler &lt;span class="p"&gt;=&lt;/span&gt; ch_open&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost:8090&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; {&lt;span class="s1"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;: &lt;span class="s1"&gt;&amp;#39;json&amp;#39;&lt;/span&gt;}&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_sendexpr&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;,&lt;/span&gt; s:data&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;call&lt;/span&gt; ch_close&lt;span class="p"&gt;(&lt;/span&gt;handler&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:py_eval&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;py_eval:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_vim&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_vim:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:json_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_py:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_raw&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;raw_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_py&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;python:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;let&lt;/span&gt; start_time &lt;span class="p"&gt;=&lt;/span&gt; reltime&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;call&lt;/span&gt; s:send_data_sock&lt;span class="p"&gt;()&lt;/span&gt;
echo &lt;span class="s1"&gt;&amp;#39;json_channel:&amp;#39;&lt;/span&gt; . reltimestr&lt;span class="p"&gt;(&lt;/span&gt;reltime&lt;span class="p"&gt;(&lt;/span&gt;start_time&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;data.txt&lt;/code&gt; には &lt;code&gt;This is sample data\n\n&lt;/code&gt; が10万回、合計20万行入っています。
Pythonの場合は Vim で読み込んだデータを python に渡す処理も入ってくるので、そこは別で計測しています。&lt;/p&gt;
&lt;p&gt;結果はこうなりました。（単位は秒、Vim のバージョンは 7.4.1265 です）&lt;/p&gt;
&lt;table class="table"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;vim (json)&lt;/th&gt;
&lt;th&gt;vim (raw)&lt;/th&gt;
&lt;th&gt;python&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vim -&amp;gt; py&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.165894&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;json化&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;0.496177&lt;/td&gt;
&lt;td&gt;0.300104&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;データ送信&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.023818&lt;/td&gt;
&lt;td&gt;0.087396&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;合計&lt;/td&gt;
&lt;td&gt;0.488828&lt;/td&gt;
&lt;td&gt;0.519995&lt;/td&gt;
&lt;td&gt;0.553394&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合計あまり変わらない・・・&lt;s&gt;Pythonよりは速くて「channelすごい！jsonすごい！」って記事になる予定だったのに・・・・&lt;/s&gt;jsonのエンコードにすごい時間かかってますね・・・よく考えたら、一度Vim scriptになってるのでむしろよく頑張ってる方だと思います。
「あれ、たしかpython標準のjsonモジュールって・・・」って&lt;a href="http://postd.cc/memory-use-and-speed-of-json-parsers/"&gt;などの疑問&lt;/a&gt;を持ってはいけません。&lt;/p&gt;
&lt;p&gt;というわけで！Pythonで処理してもあまりパフォーマンスに影響なさそうなので！むしろ20万行のマークダウンとか書かないと思うので！channelの仕様変更に負けずに地味に更新していきたいと思います！レッツポジティブ！&lt;/p&gt;</summary><category term="Vim"></category></entry><entry><title>Vim に channel が実装されたので Markdown をプレビューするプラグインを作りました</title><link href="https://miyakogi.github.io/blog/20160129/livemark1.html" rel="alternate"></link><updated>2016-01-29T19:00:00+09:00</updated><author><name>miyakogi</name></author><id>tag:miyakogi.github.io,2016-01-29:blog/20160129/livemark1.html</id><summary type="html">&lt;p&gt;Vimにchannel機能が実装されました。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mattn.kaoriya.net/software/vim/20160129114716.htm"&gt;Big Sky :: Vim にchannel(ソケット通信機能)が付いた。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨日から株価・為替は乱高下し、大臣の辞任、日銀のマイナス金利導入決定など国内では大きなニュースが続いていますが、Vimmerにとってはこのパッチが最も影響があったのではないでしょうか。&lt;/p&gt;
&lt;p&gt;というわけで、せっかくなのでchannel機能を使ってプラグインを書いてみました。
みんな大好きMarkdownのリアルタイムプレビューです。&lt;/p&gt;
&lt;!-- more --&gt;

&lt;p&gt;&lt;a href="https://github.com/miyakogi/livemark.vim"&gt;miyakogi/livemark.vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;channelを使ってみたかっただけなので、今のところデバッグ・エラー処理・設定などはやっつけです。
お遊び以外では使わないでください。&lt;/p&gt;
&lt;h2&gt;インストール&lt;/h2&gt;
&lt;p&gt;インストール方法は普通のvimプラグインと同じです。コピーするなりプラグインマネージャを使うなり、お好みの方法でインストールしてください。&lt;/p&gt;
&lt;p&gt;NeoBundleをお使いの場合は &lt;code&gt;NeoBundle 'miyakogi/livemark.vim'&lt;/code&gt; です。&lt;/p&gt;
&lt;p&gt;残念ながらVimはまだmarkdownの変換やwebサーバーなどの機能はないので、その辺りはPythonで処理しています。 以下のようにpythonのライブラリを別途インストールして下さい。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install misaka pygments tornado
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pygments はコードのシンタックスハイライトに使っています。&lt;/p&gt;
&lt;p&gt;Vimのpythonではなく外部プロセスでpythonを起動しているので、vimは&lt;code&gt;+python3&lt;/code&gt;でなくても動きます。&lt;code&gt;vimproc&lt;/code&gt;もなくて大丈夫です。&lt;/p&gt;
&lt;p&gt;Pythonのバージョンは3.5で確認していますが、たぶん3.4でも動くと思います。&lt;/p&gt;
&lt;h2&gt;使い方&lt;/h2&gt;
&lt;p&gt;Vimで適当なmarkdownファイルを開き、&lt;code&gt;:LiveMark&lt;/code&gt;を実行してください。するとchromeが起動しますので、vimでファイルを編集したりカーソルを動かしたりしてみてください。リアルタイムで変更がブラウザ上に反映されるはずです。&lt;/p&gt;
&lt;p&gt;また、Vim上のカーソル位置も取得していますので、長い文章でブラウザの画面に収まらない場合、カーソル位置が画面に収まるようにいい感じ（自称）にスクロールします。&lt;/p&gt;
&lt;p&gt;スタイルが何もないと寂しいので、&lt;a href="http://honokak.osaka/"&gt;Honoka&lt;/a&gt; という日本語向けの Bootstrap テーマを同梱させていただきました&lt;sup id="fnref:honoka-cdn"&gt;&lt;a class="footnote-ref" href="#fn:honoka-cdn" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;。日本語でもきれいに表示されると思います。&lt;/p&gt;
&lt;p&gt;終了する時は&lt;code&gt;:LiveMarkDisable&lt;/code&gt;です。何もしなくてもVimが終了した時にサーバープロセスは止まります。&lt;/p&gt;
&lt;h4&gt;手抜き感の漂うスクリーンキャスト・・・&lt;/h4&gt;
&lt;p&gt;&lt;img alt="screen cast" src="https://miyakogi.github.io/blog/images/livemark_sample.gif" /&gt;&lt;/p&gt;
&lt;h2&gt;諸注意&lt;/h2&gt;
&lt;p&gt;エラーなどでPythonのプロセスが残ってしまう場合があります。その時はプロセスを殺してください。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:honoka-cdn"&gt;
&lt;p&gt;HonokaのCDNがわからなかったのでコードを含めています。
ライセンスはMITとのことなので大丈夫だとは思いますが、もし不都合ありましたらご一報ください。&amp;#160;&lt;a class="footnote-backref" href="#fnref:honoka-cdn" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="Python"></category><category term="Vim"></category></entry></feed>